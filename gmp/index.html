<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>GMP调度模型 - zg blog</title><meta name=Description content="Stay hungry, stay foolish! 🚀"><meta property="og:url" content="https://guangzou.github.io/gmp/"><meta property="og:site_name" content="zg blog"><meta property="og:title" content="GMP调度模型"><meta property="og:description" content="从底层源码角度看 golang 的 GMP 调度模型"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2026-02-03T16:44:51+08:00"><meta property="article:modified_time" content="2026-02-04T17:59:12+08:00"><meta property="article:tag" content="Go"><meta property="og:image" content="https://guangzou.github.io/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://guangzou.github.io/logo.png"><meta name=twitter:title content="GMP调度模型"><meta name=twitter:description content="从底层源码角度看 golang 的 GMP 调度模型"><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=referrer content="no-referrer"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://guangzou.github.io/gmp/><link rel=prev href=https://guangzou.github.io/go_sql_drive_mysql/><link rel=next href=https://guangzou.github.io/func/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/fontawesome-free/css/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"GMP调度模型","inLanguage":"zh-cn","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/guangzou.github.io\/gmp\/"},"genre":"posts","keywords":"Go","wordcount":14980,"url":"https:\/\/guangzou.github.io\/gmp\/","datePublished":"2026-02-03T16:44:51+08:00","dateModified":"2026-02-04T17:59:12+08:00","license":"xxx","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"zg"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script>const query=window.matchMedia("(prefers-color-scheme: dark)");function applyTheme(){let e=window.localStorage?.getItem("theme")||"auto",t=e==="dark"||e==="auto"&&query.matches;document.body.setAttribute("theme",t?"dark":"light"),document.body.setAttribute("cfg-theme",e)}applyTheme(),query.addEventListener("change",applyTheme)</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="zg blog"><span class=header-title-pre><i class='far fa-kiss-wink-heart fa-fw' aria-hidden=true></i></span><span id=id-1 class=typeit></span><span class=header-title-post><i class='fas fa-book fa-fw'></i></span></a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="zg blog"><span class=header-title-pre><i class='far fa-kiss-wink-heart fa-fw' aria-hidden=true></i></span><span id=id-2 class=typeit></span><span class=header-title-post><i class='fas fa-book fa-fw'></i></span></a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">GMP调度模型</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>zg</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/go%E8%AF%AD%E8%A8%80/><i class="far fa-folder fa-fw" aria-hidden=true></i>Go语言</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2026-02-03>2026-02-03</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 14980 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 30 分钟&nbsp;</div></div><div class=featured-image><img class=lazyload src=/svg/loading.min.svg data-src=/images/GMP%e8%b0%83%e5%ba%a6%e6%a8%a1%e5%9e%8b%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90_banner.png data-srcset="/images/GMP%e8%b0%83%e5%ba%a6%e6%a8%a1%e5%9e%8b%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90_banner.png, /images/GMP%e8%b0%83%e5%ba%a6%e6%a8%a1%e5%9e%8b%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90_banner.png 1.5x, /images/GMP%e8%b0%83%e5%ba%a6%e6%a8%a1%e5%9e%8b%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90_banner.png 2x" data-sizes=auto alt=/images/GMP调度模型源码解析_banner.png title=/images/GMP调度模型源码解析_banner.png></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#1基础概念>1、基础概念</a><ul><li><a href=#11-进程线程协程>1.1 进程、线程、协程</a></li><li><a href=#12-gmp架构>1.2 GMP架构</a></li></ul></li><li><a href=#2go程序入口>2、go程序入口</a><ul><li><a href=#21-m0-和-g0-初始化过程>2.1 m0 和 g0 初始化过程</a></li><li><a href=#22-schedinit调度系统初始化>2.2 schedinit()调度系统初始化</a></li><li><a href=#23-创建-main-goroutine>2.3 创建 main goroutine</a><ul><li><a href=#231-systemstack切换g0栈>2.3.1 systemstack切换g0栈</a></li><li><a href=#232-新建一个-goroutine>2.3.2 新建一个 goroutine</a></li><li><a href=#233-runqput>2.3.3 runqput</a></li></ul></li><li><a href=#24-启动-gmp-调度循环>2.4 启动 GMP 调度循环</a><ul><li><a href=#241-findrunnable>2.4.1 findRunnable()</a></li><li><a href=#242-execute>2.4.2 execute</a></li></ul></li></ul></li><li><a href=#3让渡设计>3、让渡设计</a><ul><li><a href=#31-g执行完后让渡>3.1 g执行完后让渡</a></li><li><a href=#32-g主动让渡>3.2 g主动让渡</a></li><li><a href=#33-g阻塞让渡>3.3 g阻塞让渡</a></li></ul></li><li><a href=#4抢占设计>4、抢占设计</a><ul><li><a href=#41-超时抢占>4.1 超时抢占</a></li><li><a href=#42-系统调用抢占>4.2 系统调用抢占</a></li></ul></li><li><a href=#其他>其他</a><ul><li><a href=#1-补充>1 补充</a><ul><li><a href=#11-g-栈空间分布>1.1 g 栈空间分布：</a></li><li><a href=#12-goroutine-状态转换>1.2 goroutine 状态转换</a></li><li><a href=#13-抢占禁用p的next槽位>1.3 抢占禁用p的next槽位</a></li><li><a href=#14-完整启动流程>1.4 完整启动流程</a></li><li><a href=#15-一个阻塞-channel-的生命周期>1.5 一个阻塞 channel 的生命周期</a></li></ul></li><li><a href=#2-gmp-模型的进化思想>2 GMP 模型的进化思想</a></li><li><a href=#3-gmp-生态>3 GMP 生态</a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><p>从底层源码角度看 golang 的 GMP 调度模型</p><h2 id=1基础概念>1、基础概念</h2><h3 id=11-进程线程协程>1.1 进程、线程、协程</h3><p>进程是由一段静态代码经过编译为二进制可执行程序被加载到内存中经 CPU 按顺序执行的一个程序。</p><p>线程是进程中的一个执行流程，多个线程之间共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，以此来保证其控制流的独立性</p><p>协程是用户态线程，是用户程序对对线程概念的二次封装，和线程为多对一关系，在逻辑意义上属于更细粒度的调度单元，其<code>调度过程由用户态闭环完成</code>，无需内核介入</p><p>go 语言中的协程是 goroutine，能够与 M、P动态结合，体积只有几 KB，栈空间支持动态扩缩。</p><h3 id=12-gmp架构>1.2 GMP架构</h3><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/GMP%e6%9e%b6%e6%9e%84%e5%9b%be.png data-srcset="../images/GMP%e6%9e%b6%e6%9e%84%e5%9b%be.png, ../images/GMP%e6%9e%b6%e6%9e%84%e5%9b%be.png 1.5x, ../images/GMP%e6%9e%b6%e6%9e%84%e5%9b%be.png 2x" data-sizes=auto alt=../images/GMP架构图.png title=GMP架构图></p><p><strong>G</strong></p><p>goroutine，是 golang 中对协程的抽象；有自己的运行栈、生命周期状态、以及执行的任务函数（用户通过 go func 指定）；需要绑定在 m 上执行。</p><p><strong>M</strong></p><p>machine，是 golang 中对线程的抽象；跟 p 结合，它的运行目标始终在 g0 和 g 之间，当运行 g0 时执行的是 m 的调度流程，负责寻找合适的“任务”，也就是 g；当运行 g 时，执行的是 m 获取到的”任务“，也就是用户通过 go func 启动的 goroutine，不断交替运行任务：寻找任务（执行g0）；执行任务（执行g）</p><p>m 维护在一个 m 列表中，操作系统分配给当前 go 程序的线程数，m 的数目可以配置，空闲的 m 会回收或睡眠，有 m 阻塞时，会创建新的 m，因此其数目是动态的。</p><p><strong>P</strong></p><p>processor，是 golang 中的调度器，m 需要与 p 绑定后，才会进入到 gmp 调度模式当中；因此 p 的数量决定了 g 最大并行数量（通过 GOMAXPROCS 进行设定），p 是 g 的存储容器，其自带一个本地 g 队列，承载着等待被调度的 g</p><p>p 维护在一个 p 列表中，最大数目由 GOMAXPROCS 决定，可通过环境变量或 runtime 设置</p><p>如果将 GMP 看作一个任务管理系统：G 是任务，M 是运行任务的 work，P 是任务系统的中枢，跟 m 绑定开始寻找并运行 g，同时还是存储任务的容器</p><p>承载 G 的容器分为两部分：</p><ul><li><p><code>p 的本地队列 lrq（local run queue）</code>：这是每个 p 私有的 g 队列，通常由 p 自行访问，并发竞争情况较少，因此设计为无锁化结构，通过 CAS（compare-and-swap）操作访问</p></li><li><p><code>全局队列 grq（global run queue）</code>：是全局调度模块 schedt 中的全局共享 g 队列，作为当某个 lrq 不满足条件时的备用容器，因为不同的 m 都可能访问 grq，因此并发竞争比较激烈，访问前需要加全局锁</p></li></ul><p>将 g 放入容器和取出容器的流程设计：</p><ul><li><p>put g：当某个 g 中通过 go func(){&mldr;} 操作创建子 g 时，会先尝试将子 g 添加到当前所在 p 的 lrq 中（无锁化）；如果 lrq 满了，则会将 g 追加到 grq 中（全局锁）。</p></li><li><p>get g：gmp 调度流程中，m 和 p 结合后，运行的 g0 会不断寻找合适的 g 用于执行，此时会采取<code>“负载均衡”</code>的思路，遵循如下实施步骤：</p><ul><li><p>优先从当前 p 的 lrq 中获取 g（无锁化-CAS）,在 g0 每经过 61 次调度循环后，下一次在处理 lrq 前优先处理一次 grq，避免因 lrq 过于忙碌而致使 grq 陷入饥荒状态</p></li><li><p>从全局的 grq 中获取 g（全局锁）</p></li><li><p>取 io 就绪的 g（netpoll 机制）</p></li><li><p>从其他 p 的 lrq 中窃取 g（无锁化-CAS）</p></li></ul></li></ul><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/GMP%e7%bb%93%e6%9e%84%e4%bd%93.png data-srcset="../images/GMP%e7%bb%93%e6%9e%84%e4%bd%93.png, ../images/GMP%e7%bb%93%e6%9e%84%e4%bd%93.png 1.5x, ../images/GMP%e7%bb%93%e6%9e%84%e4%bd%93.png 2x" data-sizes=auto alt=../images/GMP结构体.png title=GMP架构图></p><p>全局唯一的一个 m0，就是进程的主线程，拉起 main 函数这个 groutine。</p><p>每个 m 都有一个 g0，g0 仅负责调度 g 到 m 上运行，完成一个 g 到另一个 g 的切换。</p><p><strong>M 的自旋状态</strong>：创建新的 G 时，运行的 G 会尝试唤醒其他空闲的 M 绑定 P 去执行，如果 G2 唤醒了M2，M2 绑定了一个 P2，会先运行 M2 的 G0，这时 M2 没有从 P2 的本地队列中找到 G，会进入自旋状态（spinning），自旋状态的 M2 会尝试从全局空闲线程队列里面获取 G，放到 P2 本地队列去执行，获取的数量满足公式：n = min(len(globrunqsize)/GOMAXPROCS + 1, len(localrunsize/2))，含义是每个P应该从全局队列承担的 G 数量，为了提高效率，不能太多，要给其他 P 留点；</p><p><strong>G 发生系统调用时</strong>：如果 G 发生系统调度进入阻塞，其所在的 M 也会阻塞，因为会进入内核状态等待系统资源，和 M 绑定的 P 会寻找空闲的 M 执行，这是为了提高效率，不能让 P 本地队列的 G 因所在 M 进入阻塞状态而无法执行；需要说明的是，如果是 M 上的 G 进入 Channel 阻塞，则该 M 不会一起进入阻塞，因为 Channel 数据传输涉及内存拷贝，不涉及系统资源等待；</p><p><strong>G 退出系统调用时</strong>：如果刚才进入系统调用的 G2 解除了阻塞，其所在的 M1 会寻找 P 去执行，优先找原来的 P，发现没有找到，则其上的 G2 会进入全局队列，等其他 M 获取执行，M1 进入空闲队列；</p><h2 id=2go程序入口>2、go程序入口</h2><p>查找程序的执行入口：</p><p><a href=https://zhuanlan.zhihu.com/p/654331129 target=_blank rel="noopener noreffer">https://zhuanlan.zhihu.com/p/654331129</a></p><p>一个 go 程序真正的入口在 runtime包的 src/runtime/rt0_linux_amd64.s (对 AMD64 架构上的 Linux，其他架构在不同的文件下)</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>TEXT</span> <span class=nf>_rt0_amd64_linux</span><span class=p>(</span><span class=n>SB</span><span class=p>),</span><span class=n>NOSPLIT</span><span class=p>,</span><span class=err>$</span><span class=o>-</span><span class=mi>8</span>
</span></span><span class=line><span class=cl>	<span class=n>JMP</span>	<span class=nf>_rt0_amd64</span><span class=p>(</span><span class=n>SB</span><span class=p>)</span></span></span></code></pre></div></div><p>跳转到了 src/runtime/asm_amd64.s 包的 _rt0_amd64 函数：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// _rt0_amd64 is common startup code for most amd64 systems when using
</span></span></span><span class=line><span class=cl><span class=c1>// internal linking. This is the entry point for the program from the
</span></span></span><span class=line><span class=cl><span class=c1>// kernel for an ordinary -buildmode=exe program. The stack holds the
</span></span></span><span class=line><span class=cl><span class=c1>// number of arguments and the C-style argv.
</span></span></span><span class=line><span class=cl><span class=n>TEXT</span> <span class=nf>_rt0_amd64</span><span class=p>(</span><span class=n>SB</span><span class=p>),</span><span class=n>NOSPLIT</span><span class=p>,</span><span class=err>$</span><span class=o>-</span><span class=mi>8</span>
</span></span><span class=line><span class=cl>	<span class=n>MOVQ</span>	<span class=mi>0</span><span class=p>(</span><span class=n>SP</span><span class=p>),</span> <span class=n>DI</span>	<span class=c1>// argc
</span></span></span><span class=line><span class=cl>	<span class=n>LEAQ</span>	<span class=mi>8</span><span class=p>(</span><span class=n>SP</span><span class=p>),</span> <span class=n>SI</span>	<span class=c1>// argv
</span></span></span><span class=line><span class=cl>	<span class=n>JMP</span>	<span class=n>runtime</span><span class=err>·</span><span class=nf>rt0_go</span><span class=p>(</span><span class=n>SB</span><span class=p>)</span></span></span></code></pre></div></div><p>在 asm_amd64.s 中有 runtime·rt0_go 函数的实现：</p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>TEXT</span> <span class=n>runtime</span><span class=err>·</span><span class=nf>rt0_go</span><span class=p>(</span><span class=n>SB</span><span class=p>),</span><span class=n>NOSPLIT</span><span class=o>|</span><span class=n>NOFRAME</span><span class=o>|</span><span class=n>TOPFRAME</span><span class=p>,</span><span class=err>$</span><span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=c1>// copy arguments forward on an even stack
</span></span></span><span class=line><span class=cl>	<span class=n>MOVQ</span>	<span class=n>DI</span><span class=p>,</span> <span class=n>AX</span>		<span class=c1>// argc，保存命令行参数
</span></span></span><span class=line><span class=cl>	<span class=n>MOVQ</span>	<span class=n>SI</span><span class=p>,</span> <span class=n>BX</span>		<span class=c1>// argv
</span></span></span><span class=line><span class=cl>	<span class=p>......</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// create istack out of the given (operating system) stack.
</span></span></span><span class=line><span class=cl>	<span class=c1>// _cgo_init may update stackguard.
</span></span></span><span class=line><span class=cl>  <span class=c1>// 创建初始 goroutine（g0）的栈结构，设置栈边界
</span></span></span><span class=line><span class=cl>	<span class=n>MOVQ</span>	<span class=err>$</span><span class=n>runtime</span><span class=err>·</span><span class=nf>g0</span><span class=p>(</span><span class=n>SB</span><span class=p>),</span> <span class=n>DI</span>
</span></span><span class=line><span class=cl>	<span class=nf>LEAQ</span>	<span class=p>(</span><span class=o>-</span><span class=mi>64</span><span class=o>*</span><span class=mi>1024</span><span class=p>)(</span><span class=n>SP</span><span class=p>),</span> <span class=n>BX</span>
</span></span><span class=line><span class=cl>	<span class=n>MOVQ</span>	<span class=n>BX</span><span class=p>,</span> <span class=nf>g_stackguard0</span><span class=p>(</span><span class=n>DI</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>MOVQ</span>	<span class=n>BX</span><span class=p>,</span> <span class=nf>g_stackguard1</span><span class=p>(</span><span class=n>DI</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>MOVQ</span>	<span class=n>BX</span><span class=p>,</span> <span class=p>(</span><span class=n>g_stack</span><span class=o>+</span><span class=n>stack_lo</span><span class=p>)(</span><span class=n>DI</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>MOVQ</span>	<span class=n>SP</span><span class=p>,</span> <span class=p>(</span><span class=n>g_stack</span><span class=o>+</span><span class=n>stack_hi</span><span class=p>)(</span><span class=n>DI</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>......</span>
</span></span><span class=line><span class=cl><span class=nl>ok</span><span class=p>:</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 建立 goroutine（g0）和 machine（m0）的双向关联，g0 是初始 goroutine，m0 是初始 OS 线程，使用操作系统提	 // 供的初始线程栈（通常是主线程栈）
</span></span></span><span class=line><span class=cl>	<span class=c1>// set the per-goroutine and per-mach &#34;registers&#34;
</span></span></span><span class=line><span class=cl>	<span class=nf>get_tls</span><span class=p>(</span><span class=n>BX</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>LEAQ</span>	<span class=n>runtime</span><span class=err>·</span><span class=nf>g0</span><span class=p>(</span><span class=n>SB</span><span class=p>),</span> <span class=n>CX</span>
</span></span><span class=line><span class=cl>	<span class=n>MOVQ</span>	<span class=n>CX</span><span class=p>,</span> <span class=nf>g</span><span class=p>(</span><span class=n>BX</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>LEAQ</span>	<span class=n>runtime</span><span class=err>·</span><span class=nf>m0</span><span class=p>(</span><span class=n>SB</span><span class=p>),</span> <span class=n>AX</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// save m-&gt;g0 = g0
</span></span></span><span class=line><span class=cl>	<span class=n>MOVQ</span>	<span class=n>CX</span><span class=p>,</span> <span class=nf>m_g0</span><span class=p>(</span><span class=n>AX</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// save m0 to g0-&gt;m
</span></span></span><span class=line><span class=cl>	<span class=n>MOVQ</span>	<span class=n>AX</span><span class=p>,</span> <span class=nf>g_m</span><span class=p>(</span><span class=n>CX</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>.......</span>
</span></span><span class=line><span class=cl>  <span class=c1>// 解析命令行参数，操作系统相关初始化，调度器初始化
</span></span></span><span class=line><span class=cl>	<span class=n>MOVL</span>	<span class=mi>24</span><span class=p>(</span><span class=n>SP</span><span class=p>),</span> <span class=n>AX</span>		<span class=c1>// copy argc
</span></span></span><span class=line><span class=cl>	<span class=n>MOVL</span>	<span class=n>AX</span><span class=p>,</span> <span class=mi>0</span><span class=p>(</span><span class=n>SP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>MOVQ</span>	<span class=mi>32</span><span class=p>(</span><span class=n>SP</span><span class=p>),</span> <span class=n>AX</span>		<span class=c1>// copy argv
</span></span></span><span class=line><span class=cl>	<span class=n>MOVQ</span>	<span class=n>AX</span><span class=p>,</span> <span class=mi>8</span><span class=p>(</span><span class=n>SP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>CALL</span>	<span class=n>runtime</span><span class=err>·</span><span class=nf>args</span><span class=p>(</span><span class=n>SB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>CALL</span>	<span class=n>runtime</span><span class=err>·</span><span class=nf>osinit</span><span class=p>(</span><span class=n>SB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>CALL</span>	<span class=n>runtime</span><span class=err>·</span><span class=nf>schedinit</span><span class=p>(</span><span class=n>SB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>  <span class=c1>// 创建一个新的 goroutine 来运行 runtime.main，runtime.main 最终会调用用户的 main.main()
</span></span></span><span class=line><span class=cl>	<span class=c1>// create a new goroutine to start program
</span></span></span><span class=line><span class=cl>	<span class=n>MOVQ</span>	<span class=err>$</span><span class=n>runtime</span><span class=err>·</span><span class=nf>mainPC</span><span class=p>(</span><span class=n>SB</span><span class=p>),</span> <span class=n>AX</span>		<span class=c1>// entry
</span></span></span><span class=line><span class=cl>	<span class=n>PUSHQ</span>	<span class=n>AX</span>
</span></span><span class=line><span class=cl>	<span class=n>CALL</span>	<span class=n>runtime</span><span class=err>·</span><span class=nf>newproc</span><span class=p>(</span><span class=n>SB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>POPQ</span>	<span class=n>AX</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// start this M，启动调度
</span></span></span><span class=line><span class=cl>	<span class=n>CALL</span>	<span class=n>runtime</span><span class=err>·</span><span class=nf>mstart</span><span class=p>(</span><span class=n>SB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>CALL</span>	<span class=n>runtime</span><span class=err>·</span><span class=nf>abort</span><span class=p>(</span><span class=n>SB</span><span class=p>)</span>	<span class=c1>// mstart should never return
</span></span></span><span class=line><span class=cl>	<span class=n>RET</span></span></span></code></pre></div></div><p>这个汇编函数主要做了四件事：</p><ul><li><p>建立 goroutine（g0）和 machine（m0）的双向关联，g0 是初始 goroutine，m0 是初始 OS 线程，它使用操作系统提供的初始线程栈（通常是主线程栈）</p></li><li><p>通过 runtime 中的 osinit、schedinit 等函数对 GMP 初始化。其中 osinit 主要是获取 CPU 数量，页大小等一些操作系统初始化工作</p></li><li><p>创建一个新的 goroutine 来运行 runtime.main，runtime.main 最终会调用用户的 main.main()，操作系统加载的时候只创建好了主线程，协程还是得用户态的 golang 自己管理，在这里 golang 创建出了自己的第一个协程</p></li><li><p>调用 runtime·mstart 开启调度</p></li></ul><h3 id=21-m0-和-g0-初始化过程>2.1 m0 和 g0 初始化过程</h3><p>m0 和 g0 的初始化过程：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-shell"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>// 建立 goroutine（g0）和 machine（m0）的双向关联，g0 是初始 goroutine，m0 是初始 OS 线程，使用操作系统提	 // 供的初始线程栈（通常是主线程栈）
</span></span><span class=line><span class=cl>	// <span class=nb>set</span> the per-goroutine and per-mach <span class=s2>&#34;registers&#34;</span>
</span></span><span class=line><span class=cl>	get_tls<span class=o>(</span>BX<span class=o>)</span>
</span></span><span class=line><span class=cl>	LEAQ	runtime·g0<span class=o>(</span>SB<span class=o>)</span>, CX   // 将全局变量 g0 的地址加载到 CX 寄存器，此时 CX 指向 g0 结构体
</span></span><span class=line><span class=cl>	MOVQ	CX, g<span class=o>(</span>BX<span class=o>)</span>						 //g<span class=o>(</span>BX<span class=o>)</span>宏展开为 0<span class=o>(</span>r<span class=o>)(</span>TLS*1<span class=o>)</span>，即将 CX <span class=o>(</span>g0 的地址<span class=o>)</span>存储到 TLS 的第一个槽位
</span></span><span class=line><span class=cl>	LEAQ	runtime·m0<span class=o>(</span>SB<span class=o>)</span>, AX   // 将全局变量 m0 的地址加载到 AX 寄存器
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	// save m-&gt;g0 <span class=o>=</span> g0
</span></span><span class=line><span class=cl>	MOVQ	CX, m_g0<span class=o>(</span>AX<span class=o>)</span>
</span></span><span class=line><span class=cl>	// save m0 to g0-&gt;m
</span></span><span class=line><span class=cl>	MOVQ	AX, g_m<span class=o>(</span>CX<span class=o>)</span></span></span></code></pre></div></div><p>get_tls(BX):将 TLS 基地址加载到 BX 寄存器，TLS 代表当前线程的线程本地存储区域的基地址。</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-shell"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>// get_tls<span class=o>(</span>r<span class=o>)</span> 在 go_tls.h 中定义
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#ifdef GOARCH_amd64</span>
</span></span><span class=line><span class=cl><span class=c1>#define	get_tls(r)	MOVQ TLS, r</span>
</span></span><span class=line><span class=cl><span class=c1>#define	g(r)	0(r)(TLS*1)</span>
</span></span><span class=line><span class=cl><span class=c1>#endif</span></span></span></code></pre></div></div><p>将全局变量 g0 的地址加载到 CX 寄存器，此时 CX 指向 g0 结构体</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-shell"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>LEAQ	runtime·g0<span class=o>(</span>SB<span class=o>)</span>, CX</span></span></code></pre></div></div><p>g(BX)函数展开为 0(r)(TLS*1)，即将 CX (g0 的地址)存储到 TLS 的第一个槽位,从此刻起，getg() 函数就能工作了</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-shell"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>MOVQ	CX, g<span class=o>(</span>BX<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>--------------------
</span></span><span class=line><span class=cl>// getg<span class=o>()</span>的定义如下
</span></span><span class=line><span class=cl>// getg returns the pointer to the current g.
</span></span><span class=line><span class=cl>// The compiler rewrites calls to this <span class=k>function</span> into instructions
</span></span><span class=line><span class=cl>// that fetch the g directly <span class=o>(</span>from TLS or from the dedicated register<span class=o>)</span>.
</span></span><span class=line><span class=cl>func getg<span class=o>()</span> *g</span></span></code></pre></div></div><p>将全局变量 m0 的地址加载到 AX 寄存器</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-shell"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>LEAQ	runtime·m0<span class=o>(</span>SB<span class=o>)</span>, AX</span></span></code></pre></div></div><p>此时的寄存器状态：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-shell"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>BX</span> <span class=o>=</span> TLS 基地址
</span></span><span class=line><span class=cl><span class=nv>CX</span> <span class=o>=</span> <span class=p>&amp;</span>g0
</span></span><span class=line><span class=cl><span class=nv>AX</span> <span class=o>=</span> <span class=p>&amp;</span>m0</span></span></code></pre></div></div><p>m->g0 = g0</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-shell"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>MOVQ	CX, m_g0<span class=o>(</span>AX<span class=o>)</span></span></span></code></pre></div></div><p>g0->m = m0</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-shell"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>MOVQ	AX, g_m<span class=o>(</span>CX<span class=o>)</span></span></span></code></pre></div></div><p>完成 m0 和 g0 的相互引用，通过 TLS，能够快速访问 GMP 的调度链</p><p>┌─────────────────────────────────────┐
│ 当前线程（M） │
├─────────────────────────────────────┤
│ TLS[0] → 当前 G │
│ ↓ │
│ g.m → 当前 M │
│ ↓ │
│ m.p → 当前 P │
│ ↓ │
│ p.runq → G队列 │
└─────────────────────────────────────┘</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/m0&amp;g0.png data-srcset="../images/m0&amp;g0.png, ../images/m0&amp;g0.png 1.5x, ../images/m0&amp;g0.png 2x" data-sizes=auto alt=../images/m0&amp;g0.png title=m0&amp;g0></p><p>使用 TLS 的好处：</p><p>1、通过 TLS，getg() 可以在几个 CPU 周期内完成，无需函数调用开销。</p><p>2、支持多线程每个操作系统线程（M）都有自己的 TLS：M1 的 TLS[0] 指向它当前运行的 G；M2 的 TLS[0] 指向它当前运行的 G。互不干扰，无需加锁。</p><p>3、架构无关的抽象：不同操作系统和 CPU 架构的 TLS 实现不同，通过 get_tls 宏和 g(r) 宏抽象了这些差异。</p><h3 id=22-schedinit调度系统初始化>2.2 schedinit()调度系统初始化</h3><p>schedinit() 函数对调度系统进行初始化，位于 runtime/proc.go 下，它负责初始化整个 Go 运行时环境</p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>m0</span><span class=w>           </span><span class=nx>m</span><span class=w>	</span><span class=c1>// m0 作为全局变量静态分配</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>g0</span><span class=w>           </span><span class=nx>g</span><span class=w>  </span><span class=c1>// m0 和 g0 是全局变量，在程序启动时就已经存在于数据段（.data 或 .bss 段）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>mcache0</span><span class=w>      </span><span class=o>*</span><span class=nx>mcache</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>raceprocctx0</span><span class=w> </span><span class=kt>uintptr</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>raceFiniLock</span><span class=w> </span><span class=nx>mutex</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// The bootstrap sequence is: 启动顺序</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//	call osinit</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//	call schedinit</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//	make &amp; queue new G</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//	call runtime·mstart</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// The new G calls runtime·main.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>schedinit</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>,</span><span class=w> </span><span class=nx>lockRankSched</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>deferlock</span><span class=p>,</span><span class=w> </span><span class=nx>lockRankDefer</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>sudoglock</span><span class=p>,</span><span class=w> </span><span class=nx>lockRankSudog</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>deadlock</span><span class=p>,</span><span class=w> </span><span class=nx>lockRankDeadlock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>paniclk</span><span class=p>,</span><span class=w> </span><span class=nx>lockRankPanic</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>allglock</span><span class=p>,</span><span class=w> </span><span class=nx>lockRankAllg</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>allpLock</span><span class=p>,</span><span class=w> </span><span class=nx>lockRankAllp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>lockInit</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>reflectOffs</span><span class=p>.</span><span class=nx>lock</span><span class=p>,</span><span class=w> </span><span class=nx>lockRankReflectOffs</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>traceLockInit</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>......</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>getg</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 设置最大线程数为 10000，即 M 的最大数目</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>sched</span><span class=p>.</span><span class=nx>maxmcount</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>10000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>crashFD</span><span class=p>.</span><span class=nf>Store</span><span class=p>(^</span><span class=nb>uintptr</span><span class=p>(</span><span class=mi>0</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// The world starts stopped.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>worldStopped</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>ticks</span><span class=p>.</span><span class=nf>init</span><span class=p>()</span><span class=w> </span><span class=c1>// run as early as possible,用于性能分析和调度决策，需尽早运行</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>stackinit</span><span class=p>()</span><span class=w>		</span><span class=c1>// 栈初始化</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>randinit</span><span class=p>()</span><span class=w> </span><span class=c1>// must run before mallocinit, alginit, mcommoninit，随机数初始化</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>mallocinit</span><span class=p>()</span><span class=w> </span><span class=c1>// 内存分配器初始化</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>cpuinit</span><span class=p>(</span><span class=nx>godebug</span><span class=p>)</span><span class=w> </span><span class=c1>// must run before alginit</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>alginit</span><span class=p>()</span><span class=w>        </span><span class=c1>// maps, hash, rand must not be used before this call，算法初始化（map、hash等）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>mcommoninit</span><span class=p>(</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>,</span><span class=w> </span><span class=o>-</span><span class=mi>1</span><span class=p>)</span><span class=w>  </span><span class=c1>// 初始化当前的操作系统线程（M0，即主线程）。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>stkobjinit</span><span class=p>()</span><span class=w>    </span><span class=c1>// must run before GC starts，栈对象初始化</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nf>goargs</span><span class=p>()</span><span class=w>           </span><span class=c1>// 处理命令行参数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nf>goenvs</span><span class=p>()</span><span class=w>           </span><span class=c1>// 处理环境变量</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nf>gcinit</span><span class=p>()</span><span class=w>           </span><span class=c1>// GC初始化</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// Allocate stack space that can be used when crashing due to bad stack</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// conditions, e.g. morestack on g0.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 预分配 16KB 栈空间用于崩溃处理，如：当栈溢出或其他严重错误时，使用这个栈来输出错误信息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// stackguard 栈保护边界，用于检测栈溢出</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gcrash</span><span class=p>.</span><span class=nx>stack</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>stackalloc</span><span class=p>(</span><span class=mi>16384</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gcrash</span><span class=p>.</span><span class=nx>stackguard0</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>gcrash</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>lo</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gcrash</span><span class=p>.</span><span class=nx>stackguard1</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>gcrash</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>lo</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>1000</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// GOMAXPROCS 变量设置，如果未设置，使用 CPU 核心数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>var</span><span class=w> </span><span class=nx>procs</span><span class=w> </span><span class=kt>int32</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>n</span><span class=p>,</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>strconv</span><span class=p>.</span><span class=nf>Atoi32</span><span class=p>(</span><span class=nf>gogetenv</span><span class=p>(</span><span class=s>&#34;GOMAXPROCS&#34;</span><span class=p>));</span><span class=w> </span><span class=nx>ok</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>procs</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>n</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>sched</span><span class=p>.</span><span class=nx>customGOMAXPROCS</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// Use numCPUStartup for initial GOMAXPROCS for two reasons:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>		// 1. We just computed it in osinit, recomputing is (minorly) wasteful.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>		// 2. More importantly, if debug.containermaxprocs == 0 &amp;&amp;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>//    debug.updatemaxprocs == 0, we want to guarantee that</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>//    runtime.GOMAXPROCS(0) always equals runtime.NumCPU (which is</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>//    just numCPUStartup).</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>procs</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>defaultGOMAXPROCS</span><span class=p>(</span><span class=nx>numCPUStartup</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 调用 procresize 调整 P（处理器）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nf>procresize</span><span class=p>(</span><span class=nx>procs</span><span class=p>)</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;unknown runnable goroutine during bootstrap&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// World is effectively started now, as P&#39;s can run. 标记运行时已启动，P 可以开始运行</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>worldStarted</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=o>......</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>P 的数量取决于当前 cpu 的数量，或者是 runtime.GOMAXPROCS 的配置。</p><p>几个重点：</p><ol><li>mallocinit()：内存分配器，初始化 mcache（每个 P 的本地缓存），分三级mcache、mcentral（中心缓存）、mheap（全局堆），在此之前不能进行堆内存分配</li><li>mcommoninit(gp.m, -1)：完善初始化当前 M（M0，主线程），将 M 加入全局 M 列表。前面 M0 已经存在：作为全局变量静态分配且在 rt0_go 汇编中与 g0 建立了关联，g0 和 m0 不是通过 malloc 动态分配的，而是编译时就分配好的静态内存，解决了“鸡生蛋”问题（在内存分配器初始化之前，我们需要一个 M 和 G 来运行初始化代码）</li><li>gcinit()：初始化垃圾回收器的数据结构、工作线程、写屏障等</li><li>GOMAXPROCS 初始化</li><li>procresize(procs): 调整 P 的数目和 P 处理器的初始化。</li></ol><p>重点看下<code>procresize(procs)</code>:</p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span><span class=w> </span><span class=nx>allp</span><span class=w> </span><span class=p>[]</span><span class=o>*</span><span class=nx>p</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// Change number of processors.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// sched.lock must be held, and the world must be stopped.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// gcworkbufs must not be being modified by either the GC or the write barrier</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// code, so the GC must not be running if the number of Ps actually changes.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Returns list of Ps with local work, they need to be scheduled by the caller.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>procresize</span><span class=p>(</span><span class=nx>nprocs</span><span class=w> </span><span class=kt>int32</span><span class=p>)</span><span class=w> </span><span class=o>*</span><span class=nx>p</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>assertLockHeld</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>assertWorldStopped</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=o>......</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nx>old</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>gomaxprocs</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// Grow allp if necessary.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>nprocs</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=nb>int32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>allp</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>allpLock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>nprocs</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=nb>int32</span><span class=p>(</span><span class=nb>cap</span><span class=p>(</span><span class=nx>allp</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>allp</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>allp</span><span class=p>[:</span><span class=nx>nprocs</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>nallp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>make</span><span class=p>([]</span><span class=o>*</span><span class=nx>p</span><span class=p>,</span><span class=w> </span><span class=nx>nprocs</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nb>copy</span><span class=p>(</span><span class=nx>nallp</span><span class=p>,</span><span class=w> </span><span class=nx>allp</span><span class=p>[:</span><span class=nb>cap</span><span class=p>(</span><span class=nx>allp</span><span class=p>)])</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>allp</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>nallp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>allpLock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// initialize new P&#39;s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>old</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>nprocs</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>pp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>allp</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>pp</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>pp</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nb>new</span><span class=p>(</span><span class=nx>p</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>pp</span><span class=p>.</span><span class=nf>init</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span><span class=w>  </span><span class=c1>// 设置id，初始化mcahe，设置状态为_Pgcstop</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>atomicstorep</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>allp</span><span class=p>[</span><span class=nx>i</span><span class=p>]),</span><span class=w> </span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>pp</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>getg</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>().</span><span class=nx>id</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>nprocs</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// continue to use the current P</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>().</span><span class=nx>status</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>_Prunning</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>().</span><span class=nx>mcache</span><span class=p>.</span><span class=nf>prepareForSweep</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// release the current P and acquire allp[0].</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>		// We must do this before destroying our current P</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// because p.destroy itself has write barriers, so we</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// need to do that from a valid P.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>().</span><span class=nx>m</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>pp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>allp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=w>		</span><span class=c1>// 取第一个P</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>pp</span><span class=p>.</span><span class=nx>m</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>pp</span><span class=p>.</span><span class=nx>status</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>_Pidle</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>acquirep</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// g.m.p is now set, so we no longer need mcache0 for bootstrapping.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>mcache0</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// release resources from unused P&#39;s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>nprocs</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>old</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>pp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>allp</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>pp</span><span class=p>.</span><span class=nf>destroy</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// can&#39;t free P itself because it can be referenced by an M in syscall</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// Trim allp.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nb>int32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>allp</span><span class=p>))</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>nprocs</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>allpLock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>allp</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>allp</span><span class=p>[:</span><span class=nx>nprocs</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>idlepMask</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>idlepMask</span><span class=p>[:</span><span class=nx>maskWords</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>timerpMask</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>timerpMask</span><span class=p>[:</span><span class=nx>maskWords</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>allpLock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// id 大于nprocs的 P 都不返回了</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>var</span><span class=w> </span><span class=nx>runnablePs</span><span class=w> </span><span class=o>*</span><span class=nx>p</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>nprocs</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>--</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>pp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>allp</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nx>pp</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>continue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>pp</span><span class=p>.</span><span class=nx>status</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>_Pidle</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nf>runqempty</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nf>pidleput</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span><span class=w> </span><span class=nx>now</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>pp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nf>set</span><span class=p>(</span><span class=nf>mget</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>pp</span><span class=p>.</span><span class=nx>link</span><span class=p>.</span><span class=nf>set</span><span class=p>(</span><span class=nx>runnablePs</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>runnablePs</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>pp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>stealOrder</span><span class=p>.</span><span class=nf>reset</span><span class=p>(</span><span class=nb>uint32</span><span class=p>(</span><span class=nx>nprocs</span><span class=p>))</span><span class=w>  </span><span class=c1>// 更新窃取其他 P 本地队列的 order</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>var</span><span class=w> </span><span class=nx>int32p</span><span class=w> </span><span class=o>*</span><span class=kt>int32</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=o>&amp;</span><span class=nx>gomaxprocs</span><span class=w> </span><span class=c1>// make compiler check that gomaxprocs is an int32</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>atomic</span><span class=p>.</span><span class=nf>Store</span><span class=p>((</span><span class=o>*</span><span class=kt>uint32</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>int32p</span><span class=p>)),</span><span class=w> </span><span class=nb>uint32</span><span class=p>(</span><span class=nx>nprocs</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>runnablePs</span><span class=w>  </span><span class=c1>// 返回可用的 P 链表头指针</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>wirep</span><span class=p>(</span><span class=nx>pp</span><span class=w> </span><span class=o>*</span><span class=nx>p</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>getg</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>systemstack</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;wirep: already in go&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>m</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>status</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>_Pidle</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>systemstack</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>id</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>int64</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>m</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=nx>id</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nf>ptr</span><span class=p>().</span><span class=nx>id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nb>print</span><span class=p>(</span><span class=s>&#34;wirep: p-&gt;m=&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>m</span><span class=p>,</span><span class=w> </span><span class=s>&#34;(&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>id</span><span class=p>,</span><span class=w> </span><span class=s>&#34;) p-&gt;status=&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>status</span><span class=p>,</span><span class=w> </span><span class=s>&#34;\n&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;wirep: invalid p state&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>set</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span><span class=w>  </span><span class=c1>// 当前 m 关联 p</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nf>set</span><span class=p>(</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>)</span><span class=w>  </span><span class=c1>// p 关联当前 m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pp</span><span class=p>.</span><span class=nx>status</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>_Prunning</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 乐观无锁+双重检查判队列是否为空，for循环不会一直进行下去:1、时间窗口极窄，三条原子操作只有几纳秒；2、runqtail有限次变化（p的本地队列长度有限，256），单个 P 每秒最多处理 数百万次 队列操作，但在 5 纳秒的窗口内，最多只能发生 1-2 次 修改</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// runqempty reports whether pp has no Gs on its local run queue.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// It never returns true spuriously.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>runqempty</span><span class=p>(</span><span class=nx>pp</span><span class=w> </span><span class=o>*</span><span class=nx>p</span><span class=p>)</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// Defend against a race where 1) pp has G1 in runqnext but runqhead == runqtail,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 2) runqput on pp kicks G1 to the runq, 3) runqget on pp empties runqnext.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// Simply observing that runqhead == runqtail and then observing that runqnext == nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// does not mean the queue is empty.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>head</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>Load</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runqhead</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>tail</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>Load</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runqtail</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>runnext</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>Loaduintptr</span><span class=p>((</span><span class=o>*</span><span class=kt>uintptr</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runnext</span><span class=p>)))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>tail</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>Load</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runqtail</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>return</span><span class=w> </span><span class=nx>head</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nx>tail</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>runnext</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>pidleput</span><span class=p>(</span><span class=nx>pp</span><span class=w> </span><span class=o>*</span><span class=nx>p</span><span class=p>,</span><span class=w> </span><span class=nx>now</span><span class=w> </span><span class=kt>int64</span><span class=p>)</span><span class=w> </span><span class=kt>int64</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>assertLockHeld</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nf>runqempty</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;pidleput: P has non-empty run queue&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>now</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>now</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>nanotime</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>timers</span><span class=p>.</span><span class=nx>len</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>timerpMask</span><span class=p>.</span><span class=nb>clear</span><span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>id</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>idlepMask</span><span class=p>.</span><span class=nf>set</span><span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>id</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pp</span><span class=p>.</span><span class=nx>link</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>sched</span><span class=p>.</span><span class=nx>pidle</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>sched</span><span class=p>.</span><span class=nx>pidle</span><span class=p>.</span><span class=nf>set</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>sched</span><span class=p>.</span><span class=nx>npidle</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>pp</span><span class=p>.</span><span class=nx>limiterEvent</span><span class=p>.</span><span class=nf>start</span><span class=p>(</span><span class=nx>limiterEventIdle</span><span class=p>,</span><span class=w> </span><span class=nx>now</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;must be able to track idle limiter event&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>now</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>执行完 acquirep(pp) 后此时 m0 与 g0，p0 的关系就建立起来了。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/g0m0p0.png data-srcset="../images/g0m0p0.png, ../images/g0m0p0.png 1.5x, ../images/g0m0p0.png 2x" data-sizes=auto alt=../images/g0m0p0.png title=Clipboard_Screenshot_1765446771></p><p>此后，构建 p 的空闲单向链表，更新 sched 结构体的空闲 p 链表头节点指针和空闲的 p 数目。其中 sched.pidle：全局唯一的链表头指针，存储在调度器结构体中；p.link：每个 P 结构体内部的字段，用于串联成链表，使用头插法（LIFO - 后进先出），这样头插法和头取出都是 O(1) 时间复杂度，且不需要尾指针。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/sched_pidle.png data-srcset="../images/sched_pidle.png, ../images/sched_pidle.png 1.5x, ../images/sched_pidle.png 2x" data-sizes=auto alt=../images/sched_pidle.png title=sched_pidle></p><h3 id=23-创建-main-goroutine>2.3 创建 main goroutine</h3><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl>	<span class=c1>// 创建一个新的 goroutine 来运行 runtime.main，runtime.main 最终会调用用户的 main.main()
</span></span></span><span class=line><span class=cl>	<span class=c1>// create a new goroutine to start program
</span></span></span><span class=line><span class=cl>	<span class=n>MOVQ</span>	<span class=err>$</span><span class=n>runtime</span><span class=err>·</span><span class=nf>mainPC</span><span class=p>(</span><span class=n>SB</span><span class=p>),</span> <span class=n>AX</span>		<span class=c1>// runtime·mainPC 是一个全局变量，存储了 runtime.main 函数的地址
</span></span></span><span class=line><span class=cl>	<span class=n>PUSHQ</span>	<span class=n>AX</span>												<span class=c1>// 将 mainPC 压栈作为参数
</span></span></span><span class=line><span class=cl>	<span class=n>CALL</span>	<span class=n>runtime</span><span class=err>·</span><span class=nf>newproc</span><span class=p>(</span><span class=n>SB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>POPQ</span>	<span class=n>AX</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=c1>// mainPC is a function value for runtime.main, to be passed to newproc.
</span></span></span><span class=line><span class=cl><span class=c1>// The reference to runtime.main is made via ABIInternal, since the
</span></span></span><span class=line><span class=cl><span class=c1>// actual function (not the ABI0 wrapper) is needed by newproc.
</span></span></span><span class=line><span class=cl><span class=n>DATA</span>	<span class=n>runtime</span><span class=err>·</span><span class=n>mainPC</span><span class=o>+</span><span class=mi>0</span><span class=p>(</span><span class=n>SB</span><span class=p>)</span><span class=o>/</span><span class=mi>8</span><span class=p>,</span><span class=err>$</span><span class=n>runtime</span><span class=err>·</span><span class=n>main</span><span class=o>&lt;</span><span class=n>ABIInternal</span><span class=o>&gt;</span><span class=p>(</span><span class=n>SB</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>GLOBL</span>	<span class=n>runtime</span><span class=err>·</span><span class=nf>mainPC</span><span class=p>(</span><span class=n>SB</span><span class=p>),</span><span class=n>RODATA</span><span class=p>,</span><span class=err>$</span><span class=mi>8</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=err>等价于：</span>
</span></span><span class=line><span class=cl><span class=c1>// 只读全局变量，存储 runtime.main 函数的地址
</span></span></span><span class=line><span class=cl><span class=n>var</span> <span class=n>mainPC</span> <span class=o>=</span> <span class=p>(</span><span class=o>*</span><span class=n>funcval</span><span class=p>)(</span><span class=n>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=n>runtime</span><span class=p>.</span><span class=n>main</span><span class=p>))</span></span></span></code></pre></div></div><p>调用 newproc()，当写 go func() 时，编译器会将其转换为对 newproc 的调用。</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Create a new g running fn.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// Put it on the queue of g&#39;s waiting to run.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// The compiler turns a go statement into a call to this.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>newproc</span><span class=p>(</span><span class=nx>fn</span><span class=w> </span><span class=o>*</span><span class=nx>funcval</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>getg</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pc</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>sys</span><span class=p>.</span><span class=nf>GetCallerPC</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>systemstack</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>newg</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>newproc1</span><span class=p>(</span><span class=nx>fn</span><span class=p>,</span><span class=w> </span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>pc</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=nx>waitReasonZero</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>pp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>getg</span><span class=p>().</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>runqput</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span><span class=w> </span><span class=nx>newg</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>mainStarted</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nf>wakep</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><h4 id=231-systemstack切换g0栈>2.3.1 systemstack切换g0栈</h4><p>systemstack()，切换系统栈，保存当前 goroutine 的上下文，如果已经在 g0 或 gsignal 上，则直接执行，否则切换到 g0 栈，执行传入的函数，执行完毕后恢复原来的 goroutine 上下文。</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// systemstack runs fn on a system stack.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// If systemstack is called from the per-OS-thread (g0) stack, or</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// if systemstack is called from the signal handling (gsignal) stack,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// systemstack calls fn directly and returns.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// Otherwise, systemstack is being called from the limited stack</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// of an ordinary goroutine. In this case, systemstack switches</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// to the per-OS-thread stack, calls fn, and switches back.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// It is common to use a func literal as the argument, in order</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// to share inputs and outputs with the code around the call</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// to system stack:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//	... set up y ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//	systemstack(func() {</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//		x = bigcall(y)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//	})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//	... use x ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>//go:noescape</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>systemstack</span><span class=p>(</span><span class=nx>fn</span><span class=w> </span><span class=kd>func</span><span class=p>())</span></span></span></code></pre></div></div><p>系统栈（g0 栈）上执行，空间更大，不会栈增长，避免在用户 goroutine 栈上执行可能因为栈增长的操作，导致的递归问题；不会触发 GC 扫描（g0 的栈不需要扫描），安全地操作 schd 调度器数据结构，不会被抢占，为 runtime 提供了一个稳定、安全、高效的执行环境。</p><h4 id=232-新建一个-goroutine>2.3.2 新建一个 goroutine</h4><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Create a new g in state _Grunnable (or _Gwaiting if parked is true), starting at fn.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// callerpc is the address of the go statement that created this. The caller is responsible</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// for adding the new g to the scheduler. If parked is true, waitreason must be non-zero.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>newproc1</span><span class=p>(</span><span class=nx>fn</span><span class=w> </span><span class=o>*</span><span class=nx>funcval</span><span class=p>,</span><span class=w> </span><span class=nx>callergp</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=p>,</span><span class=w> </span><span class=nx>callerpc</span><span class=w> </span><span class=kt>uintptr</span><span class=p>,</span><span class=w> </span><span class=nx>parked</span><span class=w> </span><span class=kt>bool</span><span class=p>,</span><span class=w> </span><span class=nx>waitreason</span><span class=w> </span><span class=nx>waitReason</span><span class=p>)</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 防止创建一个没有执行函数的 goroutine，var f func() 和 go f() 等会触发 fatal error</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>fn</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>fatal</span><span class=p>(</span><span class=s>&#34;go of nil func value&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>mp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>acquirem</span><span class=p>()</span><span class=w> </span><span class=c1>// disable preemption because we hold M and P in local vars.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>mp</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>newg</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>gfget</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>newg</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>newg</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>malg</span><span class=p>(</span><span class=nx>stackMin</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>casgstatus</span><span class=p>(</span><span class=nx>newg</span><span class=p>,</span><span class=w> </span><span class=nx>_Gidle</span><span class=p>,</span><span class=w> </span><span class=nx>_Gdead</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>allgadd</span><span class=p>(</span><span class=nx>newg</span><span class=p>)</span><span class=w> </span><span class=c1>// publishes with a g-&gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>newg</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>hi</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;newproc1: newg missing stack&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nf>readgstatus</span><span class=p>(</span><span class=nx>newg</span><span class=p>)</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>_Gdead</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;newproc1: new g is not Gdead&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// g结构体的各个字段值的赋值</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>totalSize</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>uintptr</span><span class=p>(</span><span class=mi>4</span><span class=o>*</span><span class=nx>goarch</span><span class=p>.</span><span class=nx>PtrSize</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>sys</span><span class=p>.</span><span class=nx>MinFrameSize</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>totalSize</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>alignUp</span><span class=p>(</span><span class=nx>totalSize</span><span class=p>,</span><span class=w> </span><span class=nx>sys</span><span class=p>.</span><span class=nx>StackAlign</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>sp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>newg</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>hi</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=nx>totalSize</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>memclrNoHeapPointers</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>newg</span><span class=p>.</span><span class=nx>sched</span><span class=p>),</span><span class=w> </span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nx>newg</span><span class=p>.</span><span class=nx>sched</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>newg</span><span class=p>.</span><span class=nx>sched</span><span class=p>.</span><span class=nx>sp</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>sp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>newg</span><span class=p>.</span><span class=nx>stktopsp</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>sp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>newg</span><span class=p>.</span><span class=nx>sched</span><span class=p>.</span><span class=nx>pc</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>abi</span><span class=p>.</span><span class=nf>FuncPCABI0</span><span class=p>(</span><span class=nx>goexit</span><span class=p>)</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>sys</span><span class=p>.</span><span class=nx>PCQuantum</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>newg</span><span class=p>.</span><span class=nx>sched</span><span class=p>.</span><span class=nx>g</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>guintptr</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>newg</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>gostartcallfn</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>newg</span><span class=p>.</span><span class=nx>sched</span><span class=p>,</span><span class=w> </span><span class=nx>fn</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>newg</span><span class=p>.</span><span class=nx>parentGoid</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>callergp</span><span class=p>.</span><span class=nx>goid</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>newg</span><span class=p>.</span><span class=nx>gopc</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>callerpc</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>newg</span><span class=p>.</span><span class=nx>ancestors</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>saveAncestors</span><span class=p>(</span><span class=nx>callergp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>newg</span><span class=p>.</span><span class=nx>startpc</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>fn</span><span class=p>.</span><span class=nx>fn</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>var</span><span class=w> </span><span class=nx>status</span><span class=w> </span><span class=kt>uint32</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>_Grunnable</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>parked</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>status</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>_Gwaiting</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>newg</span><span class=p>.</span><span class=nx>waitreason</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>waitreason</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>newg</span><span class=p>.</span><span class=nx>goid</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>goidcache</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>casgstatus</span><span class=p>(</span><span class=nx>newg</span><span class=p>,</span><span class=w> </span><span class=nx>_Gdead</span><span class=p>,</span><span class=w> </span><span class=nx>status</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	
</span></span></span><span class=line><span class=cl><span class=w>	
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>releasem</span><span class=p>(</span><span class=nx>mp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>newg</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>参数说明：</p><ul><li>fn *funcval：要执行的函数（包含函数指针和闭包变量）</li><li>gp *g：父 goroutine（当前 goroutine）</li><li>pc uintptr：调用者的 PC（创建位置），即 go 语句的位置</li><li>false：parked 参数，表示新 goroutine 不是处于等待状态</li><li>waitReasonZero：等待原因（这里为0，因为不等待）</li></ul><p>Part 1:</p><p>禁止当前 m 被抢占，绑定 m 和 p，从 p 的本地队列中获取空闲的 g，若没有则从全局队列中批量获取空闲的 g，仍然没有则创建一个 g，并分配栈空间，标记状态为 <code>_Gdead</code>，并添加到 allgs 中（全局变量，维持着所有的 g 数组，主要用来统计）</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>mp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>acquirem</span><span class=p>()</span><span class=w> </span><span class=c1>// disable preemption because we hold M and P in local vars.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>pp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>mp</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>newg</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>gfget</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>if</span><span class=w> </span><span class=nx>newg</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nx>newg</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>malg</span><span class=p>(</span><span class=nx>stackMin</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nf>casgstatus</span><span class=p>(</span><span class=nx>newg</span><span class=p>,</span><span class=w> </span><span class=nx>_Gidle</span><span class=p>,</span><span class=w> </span><span class=nx>_Gdead</span><span class=p>)</span><span class=w> </span><span class=c1>// 切换状态</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nf>allgadd</span><span class=p>(</span><span class=nx>newg</span><span class=p>)</span><span class=w>	</span><span class=c1>// 添加到全局数组 allgs    []*g</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>if</span><span class=w> </span><span class=nx>newg</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>hi</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;newproc1: newg missing stack&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>if</span><span class=w> </span><span class=nf>readgstatus</span><span class=p>(</span><span class=nx>newg</span><span class=p>)</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>_Gdead</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;newproc1: new g is not Gdead&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=cp>//go:nosplit</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>acquirem</span><span class=p>()</span><span class=w> </span><span class=o>*</span><span class=nx>m</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>getg</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>locks</span><span class=o>++</span><span class=w>  </span><span class=c1>// 绑定 m 与 p，禁止抢占</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>gfget 获取 g：</p><ul><li><p>优先从 pp.gFree.pop() 获取空闲的 g</p></li><li><p>retry 循环中不断从获取 sched.gFree 全局队列中获取空闲的 g，获取时优先获取那些已经分配了栈空间的 g</p></li><li><p>为 g 分配栈空间，若已分配则判断其栈空间大小是否与起始栈空间大小一致，不一致则重新分配。</p></li></ul><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Get from gfree list.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// If local list is empty, grab a batch from global list.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>gfget</span><span class=p>(</span><span class=nx>pp</span><span class=w> </span><span class=o>*</span><span class=nx>p</span><span class=p>)</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>retry</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>gFree</span><span class=p>.</span><span class=nf>empty</span><span class=p>()</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=p>(!</span><span class=nx>sched</span><span class=p>.</span><span class=nx>gFree</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nf>empty</span><span class=p>()</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>!</span><span class=nx>sched</span><span class=p>.</span><span class=nx>gFree</span><span class=p>.</span><span class=nx>noStack</span><span class=p>.</span><span class=nf>empty</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>gFree</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// Move a batch of free Gs to the P.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>for</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>gFree</span><span class=p>.</span><span class=nx>size</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=mi>32</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=c1>// 优先获取那些已经分配了栈空间的 g</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>sched</span><span class=p>.</span><span class=nx>gFree</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nf>pop</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=nx>gp</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>sched</span><span class=p>.</span><span class=nx>gFree</span><span class=p>.</span><span class=nx>noStack</span><span class=p>.</span><span class=nf>pop</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>					</span><span class=k>break</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>pp</span><span class=p>.</span><span class=nx>gFree</span><span class=p>.</span><span class=nf>push</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>gFree</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>goto</span><span class=w> </span><span class=nx>retry</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>gFree</span><span class=p>.</span><span class=nf>pop</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 如果 g 已经分配了栈空间，并且栈空间大小不等于起始栈空间大小，需要重新分配，确保每个新使用的 g的栈空间都是从 startingStackSize（2KB，该值可设置调整） 开始</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>lo</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>hi</span><span class=o>-</span><span class=nx>gp</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>lo</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nb>uintptr</span><span class=p>(</span><span class=nx>startingStackSize</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>systemstack</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nf>stackfree</span><span class=p>(</span><span class=nx>gp</span><span class=p>.</span><span class=nx>stack</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>gp</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>lo</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>gp</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>hi</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>gp</span><span class=p>.</span><span class=nx>stackguard0</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>lo</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// Stack was deallocated in gfput or just above. Allocate a new one.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>systemstack</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>gp</span><span class=p>.</span><span class=nx>stack</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>stackalloc</span><span class=p>(</span><span class=nx>startingStackSize</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp</span><span class=p>.</span><span class=nx>stackguard0</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>lo</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>stackGuard</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>gp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>malg(stackMin)，p 本地队列和全局队列都没有空闲的 g 时，则新建 g</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Allocate a new g, with a stack big enough for stacksize bytes.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>malg</span><span class=p>(</span><span class=nx>stacksize</span><span class=w> </span><span class=kt>int32</span><span class=p>)</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>newg</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>new</span><span class=p>(</span><span class=nx>g</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>stacksize</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>stacksize</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>round2</span><span class=p>(</span><span class=nx>stackSystem</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>stacksize</span><span class=p>)</span><span class=w>  </span><span class=c1>// 按2的指数向上取整</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>systemstack</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>newg</span><span class=p>.</span><span class=nx>stack</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>stackalloc</span><span class=p>(</span><span class=nb>uint32</span><span class=p>(</span><span class=nx>stacksize</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>newg</span><span class=p>.</span><span class=nx>stackguard0</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>newg</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>lo</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>stackGuard</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>newg</span><span class=p>.</span><span class=nx>stackguard1</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=p>^</span><span class=nb>uintptr</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// Clear the bottom word of the stack. We record g</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// there on gsignal stack during VDSO on ARM and ARM64.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=kt>uintptr</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>newg</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>lo</span><span class=p>))</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>newg</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>Part2: g结构体的各个字段值的赋值</p><h4 id=233-runqput>2.3.3 runqput</h4><p>runqput 函数负责将一个 goroutine (gp) 放入 P (pp) 的本地可运行队列中。有两种放置模式：
普通模式：将 goroutine 放到队列尾部
next 模式：将 goroutine 放到 pp.runnext 槽位（优先执行）</p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// runqput tries to put g on the local runnable queue.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// If next is false, runqput adds g to the tail of the runnable queue.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// If next is true, runqput puts g in the pp.runnext slot.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// If the run queue is full, runnext puts g on the global queue.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// Executed only by the owner P.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>runqput</span><span class=p>(</span><span class=nx>pp</span><span class=w> </span><span class=o>*</span><span class=nx>p</span><span class=p>,</span><span class=w> </span><span class=nx>gp</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=p>,</span><span class=w> </span><span class=nx>next</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>haveSysmon</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>next</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// A runnext goroutine shares the same time slice as the</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// current goroutine (inheritTime from runqget). To prevent a</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// ping-pong pair of goroutines from starving all others, we</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// depend on sysmon to preempt &#34;long-running goroutines&#34;. That</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// is, any set of goroutines sharing the same time slice.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>		// If there is no sysmon, we must avoid runnext entirely or</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// risk starvation.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>next</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>next</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>retryNext</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>oldnext</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>runnext</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runnext</span><span class=p>.</span><span class=nf>cas</span><span class=p>(</span><span class=nx>oldnext</span><span class=p>,</span><span class=w> </span><span class=nf>guintptr</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>gp</span><span class=p>)))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>goto</span><span class=w> </span><span class=nx>retryNext</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>oldnext</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// Kick the old runnext out to the regular run queue.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>oldnext</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>retry</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>h</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadAcq</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runqhead</span><span class=p>)</span><span class=w> </span><span class=c1>// load-acquire, synchronize with consumers</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>t</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>runqtail</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>t</span><span class=o>-</span><span class=nx>h</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nb>uint32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runq</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runq</span><span class=p>[</span><span class=nx>t</span><span class=o>%</span><span class=nb>uint32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runq</span><span class=p>))].</span><span class=nf>set</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>atomic</span><span class=p>.</span><span class=nf>StoreRel</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runqtail</span><span class=p>,</span><span class=w> </span><span class=nx>t</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=c1>// store-release, makes the item available for consumption</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nf>runqputslow</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span><span class=w> </span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>h</span><span class=p>,</span><span class=w> </span><span class=nx>t</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>goto</span><span class=w> </span><span class=nx>retry</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>如果本地队列已经放满了，那么就往全局队列中放。即调用 <code>runqputslow</code>，这里会将 p 一半的本地队列和当前 goroutine 批量转移到全局队列，批量操作，操作全局队列需要加锁。全局队列按照链表串联起来，无限容量，有锁，起一个兜底作用。</p><h3 id=24-启动-gmp-调度循环>2.4 启动 GMP 调度循环</h3><p>整体流程：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/findRunnable%e6%b5%81%e7%a8%8b%e5%9b%be.png data-srcset="../images/findRunnable%e6%b5%81%e7%a8%8b%e5%9b%be.png, ../images/findRunnable%e6%b5%81%e7%a8%8b%e5%9b%be.png 1.5x, ../images/findRunnable%e6%b5%81%e7%a8%8b%e5%9b%be.png 2x" data-sizes=auto alt=../images/findRunnable流程图.png title=sched_pidle></p><p>汇编：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-c"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// start this M，启动调度
</span></span></span><span class=line><span class=cl>	<span class=n>CALL</span>	<span class=n>runtime</span><span class=err>·</span><span class=nf>mstart</span><span class=p>(</span><span class=n>SB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=n>TEXT</span> <span class=n>runtime</span><span class=err>·</span><span class=nf>mstart</span><span class=p>(</span><span class=n>SB</span><span class=p>),</span><span class=n>NOSPLIT</span><span class=o>|</span><span class=n>TOPFRAME</span><span class=o>|</span><span class=n>NOFRAME</span><span class=p>,</span><span class=err>$</span><span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=n>CALL</span>	<span class=n>runtime</span><span class=err>·</span><span class=nf>mstart0</span><span class=p>(</span><span class=n>SB</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>RET</span> <span class=c1>// not reached
</span></span></span></code></pre></div></div><p>在 runtime 中调用 mstart0，mstart0 中调用 mstart1，它的实现在 proc.go 中：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>mstart1</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>getg</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>g0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;bad runtime·mstart&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 保存返回点，执行完后需要回到调用方的下一条语句上继续执行</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>sched</span><span class=p>.</span><span class=nx>g</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>guintptr</span><span class=p>(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=nx>gp</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>sched</span><span class=p>.</span><span class=nx>pc</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>sys</span><span class=p>.</span><span class=nf>GetCallerPC</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>sched</span><span class=p>.</span><span class=nx>sp</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>sys</span><span class=p>.</span><span class=nf>GetCallerSP</span><span class=p>()</span><span class=w>	
</span></span></span><span class=line><span class=cl><span class=w>	
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 如果当前 m 不等于 m0，则需要绑定一个 p</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=o>&amp;</span><span class=nx>m0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>acquirep</span><span class=p>(</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>nextp</span><span class=p>.</span><span class=nf>ptr</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>nextp</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>schedule</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>schedule()：开启GMP调度，不在返回，循环执行下去</p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// One round of scheduler: find a runnable goroutine and execute it.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// Never returns.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>schedule</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>mp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>getg</span><span class=p>().</span><span class=nx>m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 省略其他代码......</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>top</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>mp</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pp</span><span class=p>.</span><span class=nx>preempt</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// Safety check: if we are spinning, the run queue should be empty.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// Check this before calling checkTimers, as that might call</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// goready to put a ready goroutine on the local run queue.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>mp</span><span class=p>.</span><span class=nx>spinning</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runnext</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>runqhead</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>runqtail</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;schedule: spinning with local work&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 找到一个可执行的goroutine</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>inheritTime</span><span class=p>,</span><span class=w> </span><span class=nx>tryWakeP</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>findRunnable</span><span class=p>()</span><span class=w> </span><span class=c1>// blocks until work is available</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 解除M自旋</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>mp</span><span class=p>.</span><span class=nx>spinning</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>resetspinning</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// If about to schedule a not-normal goroutine (a GCworker or tracereader),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// wake a P if there is one.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>tryWakeP</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>wakep</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 执行 goroutine</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>execute</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>inheritTime</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><h4 id=241-findrunnable>2.4.1 findRunnable()</h4><p>函数返回值，分别代表：</p><ul><li>gp：找到的 goroutine</li><li>inheritTime：是否继承时间片</li><li>tryWakeP：是否需要唤醒其他 P</li></ul><p>findRunnable() 查找顺序：</p><ol><li><p>清理和初始化
├─ 清除 allp 快照
├─ 检查 GC 等待 → gcstopm() → goto top
├─ 检查安全点函数 → runSafePointFn()
└─ 检查定时器</p></li><li><p>特殊 goroutine（优先级最高）
├─ Trace reader (tryWakeP=true)
└─ GC worker (tryWakeP=true)</p></li><li><p>全局队列公平性检查（每 61 次）
└─ schedtick % 61 == 0 → globrunqget()</p></li><li><p>唤醒特殊 goroutine
├─ Finalizer goroutine
└─ GC cleanup goroutine</p></li><li><p>本地队列（快速路径）
└─ runqget(pp) → 优先检查 runnext</p></li><li><p>全局队列（批量获取）
└─ globrunqgetbatch() → 获取一半到本地队列</p></li><li><p>网络轮询（非阻塞）
└─ netpoll(0) → 检查就绪的网络 I/O</p></li><li><p>工作窃取
└─ stealWork() → 从其他 P 窃取</p></li><li><p>空闲 GC 标记
└─ 如果有 GC 工作，运行空闲标记</p></li><li><p>准备休眠
├─ 释放 P
├─ 再次检查所有队列
├─ 网络轮询（阻塞）
└─ stopm() → 休眠 M</p></li></ol><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>findRunnable</span><span class=p>()</span><span class=w> </span><span class=p>(</span><span class=nx>gp</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=p>,</span><span class=w> </span><span class=nx>inheritTime</span><span class=p>,</span><span class=w> </span><span class=nx>tryWakeP</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>mp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>getg</span><span class=p>().</span><span class=nx>m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>top</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 获取 p</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>mp</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>sched</span><span class=p>.</span><span class=nx>gcwaiting</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>gcstopm</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>goto</span><span class=w> </span><span class=nx>top</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>if</span><span class=w> </span><span class=nx>gcBlackenEnabled</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>tnow</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>gcController</span><span class=p>.</span><span class=nf>findRunnableGCWorker</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span><span class=w> </span><span class=nx>now</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>return</span><span class=w> </span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>now</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>tnow</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 每 61 次调度，需要尝试处理一次全局队列 (防止饥饿)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>schedtick</span><span class=o>%</span><span class=mi>61</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=p>!</span><span class=nx>sched</span><span class=p>.</span><span class=nx>runq</span><span class=p>.</span><span class=nf>empty</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>globrunqget</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>return</span><span class=w> </span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// local runq</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>inheritTime</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>runqget</span><span class=p>(</span><span class=nx>pp</span><span class=p>);</span><span class=w> </span><span class=nx>gp</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>inheritTime</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// global runq</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>sched</span><span class=p>.</span><span class=nx>runq</span><span class=p>.</span><span class=nf>empty</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>q</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>globrunqgetbatch</span><span class=p>(</span><span class=nb>int32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runq</span><span class=p>))</span><span class=w> </span><span class=o>/</span><span class=w> </span><span class=mi>2</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=nf>runqputbatch</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=nx>q</span><span class=p>);</span><span class=w> </span><span class=p>!</span><span class=nx>q</span><span class=p>.</span><span class=nf>empty</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;Couldn&#39;t put Gs into empty local runq&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>return</span><span class=w> </span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 从网络就绪io中读取，netpoll，返回io就绪的 g</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>if</span><span class=w> </span><span class=nf>netpollinited</span><span class=p>()</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nf>netpollAnyWaiters</span><span class=p>()</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>sched</span><span class=p>.</span><span class=nx>lastpoll</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>sched</span><span class=p>.</span><span class=nx>pollingNet</span><span class=p>.</span><span class=nf>Swap</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>list</span><span class=p>,</span><span class=w> </span><span class=nx>delta</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>netpoll</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>sched</span><span class=p>.</span><span class=nx>pollingNet</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>list</span><span class=p>.</span><span class=nf>empty</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// non-blocking</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>list</span><span class=p>.</span><span class=nf>pop</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nf>injectglist</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>list</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nf>netpollAdjustWaiters</span><span class=p>(</span><span class=nx>delta</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>_Gwaiting</span><span class=p>,</span><span class=w> </span><span class=nx>_Grunnable</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>return</span><span class=w> </span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// Spinning Ms: steal work from other Ps.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>	// Limit the number of spinning Ms to half the number of busy Ps.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// This is necessary to prevent excessive CPU consumption when</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// GOMAXPROCS&gt;&gt;1 but the program parallelism is low.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>mp</span><span class=p>.</span><span class=nx>spinning</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=mi>2</span><span class=o>*</span><span class=nx>sched</span><span class=p>.</span><span class=nx>nmspinning</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>gomaxprocs</span><span class=o>-</span><span class=nx>sched</span><span class=p>.</span><span class=nx>npidle</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>mp</span><span class=p>.</span><span class=nx>spinning</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>mp</span><span class=p>.</span><span class=nf>becomeSpinning</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 窃取其他 p 的 g</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>inheritTime</span><span class=p>,</span><span class=w> </span><span class=nx>tnow</span><span class=p>,</span><span class=w> </span><span class=nx>w</span><span class=p>,</span><span class=w> </span><span class=nx>newWork</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>stealWork</span><span class=p>(</span><span class=nx>now</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=c1>// Successfully stole.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>return</span><span class=w> </span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>inheritTime</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>......</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// We have nothing to do.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 若存在 gc 并发标记任务，做GC标记工作，好过直接回收 p</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// If we&#39;re in the GC mark phase, can safely scan and blacken objects,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// and have work to do, run idle-time marking rather than give up the P. </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>gcBlackenEnabled</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nf>gcMarkWorkAvailable</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>gcController</span><span class=p>.</span><span class=nf>addIdleMarkWorker</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>node</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=p>(</span><span class=o>*</span><span class=nx>gcBgMarkWorkerNode</span><span class=p>)(</span><span class=nx>gcBgMarkWorkerPool</span><span class=p>.</span><span class=nf>pop</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>node</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>pp</span><span class=p>.</span><span class=nx>gcMarkWorkerMode</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>gcMarkWorkerIdleMode</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>node</span><span class=p>.</span><span class=nx>gp</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>_Gwaiting</span><span class=p>,</span><span class=w> </span><span class=nx>_Grunnable</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>return</span><span class=w> </span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gcController</span><span class=p>.</span><span class=nf>removeIdleMarkWorker</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 加全局锁，并 double check 全局队列是否有 g</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>sched</span><span class=p>.</span><span class=nx>runqsize</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>globrunqget</span><span class=p>(</span><span class=nx>_p_</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 确认当前 p 无事可做，则将 p 和 m 解绑，并将其添加到全局调度模块 schedt 中的空闲 p 队列 pidle 中 </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>if</span><span class=w> </span><span class=nf>releasep</span><span class=p>()</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>pp</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;findrunnable: wrong p&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>now</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>pidleput</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span><span class=w> </span><span class=nx>now</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>......</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 走到此处仍然未找到合适的 g 用于调度，则需要将 m block 住，添加到 schedt 的 midle 中</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nf>stopm</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>goto</span><span class=w> </span><span class=nx>top</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p><strong>1、从本地队列lrq获取g</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>runqget</span><span class=p>(</span><span class=nx>pp</span><span class=w> </span><span class=o>*</span><span class=nx>p</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=nx>gp</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=p>,</span><span class=w> </span><span class=nx>inheritTime</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// If there&#39;s a runnext, it&#39;s the next G to run.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>next</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>runnext</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>next</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>runnext</span><span class=p>.</span><span class=nf>cas</span><span class=p>(</span><span class=nx>next</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w> </span><span class=nx>next</span><span class=p>.</span><span class=nf>ptr</span><span class=p>(),</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 尝试基于 cas 操作，获取本地队列头节点中的 g</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>h</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadAcq</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runqhead</span><span class=p>)</span><span class=w> </span><span class=c1>// load-acquire, synchronize with other consumers</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>t</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>runqtail</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 头尾相等，说明队列为空</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>t</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nx>h</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 取出头节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>runq</span><span class=p>[</span><span class=nx>h</span><span class=o>%</span><span class=nb>uint32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runq</span><span class=p>))].</span><span class=nf>ptr</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 通过 cas 操作更新头节点索引</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>CasRel</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runqhead</span><span class=p>,</span><span class=w> </span><span class=nx>h</span><span class=p>,</span><span class=w> </span><span class=nx>h</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=c1>// cas-release, commits consume</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>return</span><span class=w> </span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p><strong>2、从全局队列中获取g</strong></p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// A gQueue is a dequeue of Gs linked through g.schedlink. A G can only</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// be on one gQueue or gList at a time.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>type</span><span class=w> </span><span class=nx>gQueue</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>head</span><span class=w> </span><span class=nx>guintptr</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>tail</span><span class=w> </span><span class=nx>guintptr</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>size</span><span class=w> </span><span class=kt>int32</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>globrunqgetbatch</span><span class=p>(</span><span class=nx>n</span><span class=w> </span><span class=kt>int32</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=nx>gp</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=p>,</span><span class=w> </span><span class=nx>q</span><span class=w> </span><span class=nx>gQueue</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>assertLockHeld</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 为空直接返回</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>sched</span><span class=p>.</span><span class=nx>runq</span><span class=p>.</span><span class=nx>size</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 据传入的 max 值尝试获取 grq 中的半数 g 填充到 p 的 lrq 中</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>n</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nb>min</span><span class=p>(</span><span class=nx>n</span><span class=p>,</span><span class=w> </span><span class=nx>sched</span><span class=p>.</span><span class=nx>runq</span><span class=p>.</span><span class=nx>size</span><span class=p>,</span><span class=w> </span><span class=nx>sched</span><span class=p>.</span><span class=nx>runq</span><span class=p>.</span><span class=nx>size</span><span class=o>/</span><span class=nx>gomaxprocs</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>sched</span><span class=p>.</span><span class=nx>runq</span><span class=p>.</span><span class=nf>pop</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>n</span><span class=o>--</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=p>;</span><span class=w> </span><span class=nx>n</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>n</span><span class=o>--</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp1</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>sched</span><span class=p>.</span><span class=nx>runq</span><span class=p>.</span><span class=nf>pop</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>q</span><span class=p>.</span><span class=nf>pushBack</span><span class=p>(</span><span class=nx>gp1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 批量存放到p的本地队列</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>runqputbatch</span><span class=p>(</span><span class=nx>pp</span><span class=w> </span><span class=o>*</span><span class=nx>p</span><span class=p>,</span><span class=w> </span><span class=nx>q</span><span class=w> </span><span class=o>*</span><span class=nx>gQueue</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>q</span><span class=p>.</span><span class=nf>empty</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>h</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>LoadAcq</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runqhead</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>t</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>runqtail</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>n</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>uint32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=p>!</span><span class=nx>q</span><span class=p>.</span><span class=nf>empty</span><span class=p>()</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>t</span><span class=o>-</span><span class=nx>h</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nb>uint32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runq</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>q</span><span class=p>.</span><span class=nf>pop</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runq</span><span class=p>[</span><span class=nx>t</span><span class=o>%</span><span class=nb>uint32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runq</span><span class=p>))].</span><span class=nf>set</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>t</span><span class=o>++</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>n</span><span class=o>++</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 更新尾节点</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>atomic</span><span class=p>.</span><span class=nf>StoreRel</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pp</span><span class=p>.</span><span class=nx>runqtail</span><span class=p>,</span><span class=w> </span><span class=nx>t</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p><strong>3、获取io就绪的g</strong></p><p>以非阻塞模式下的 epoll_wait 操作获取 io 就绪的 g。 该方法位于 runtime/netpoll_epoll.go，是 Linux 平台上基于 epoll 实现的网络轮询器核心函数</p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// netpoll checks for ready network connections.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// Returns a list of goroutines that become runnable,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// and a delta to add to netpollWaiters.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// This must never return an empty list with a non-zero delta.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// delay &lt; 0: blocks indefinitely 无限期阻塞</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// delay == 0: does not block, just polls</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// delay &gt; 0: block for up to that many nanoseconds 阻塞纳秒数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>netpoll</span><span class=p>(</span><span class=nx>delay</span><span class=w> </span><span class=kt>int64</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=nx>gList</span><span class=p>,</span><span class=w> </span><span class=kt>int32</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=o>......</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>var</span><span class=w> </span><span class=nx>events</span><span class=w> </span><span class=p>[</span><span class=mi>128</span><span class=p>]</span><span class=nx>linux</span><span class=p>.</span><span class=nx>EpollEvent</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>retry</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>n</span><span class=p>,</span><span class=w> </span><span class=nx>errno</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>linux</span><span class=p>.</span><span class=nf>EpollWait</span><span class=p>(</span><span class=nx>epfd</span><span class=p>,</span><span class=w> </span><span class=nx>events</span><span class=p>[:],</span><span class=w> </span><span class=nb>int32</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>events</span><span class=p>)),</span><span class=w> </span><span class=nx>waitms</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=o>......</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 遍历所有就绪的事件</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>var</span><span class=w> </span><span class=nx>toRun</span><span class=w> </span><span class=nx>gList</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>delta</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>int32</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>int32</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>n</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>ev</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>events</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>ev</span><span class=p>.</span><span class=nx>Events</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>continue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=o>*</span><span class=p>(</span><span class=o>**</span><span class=kt>uintptr</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>ev</span><span class=p>.</span><span class=nx>Data</span><span class=p>))</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=o>&amp;</span><span class=nx>netpollEventFd</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=nx>ev</span><span class=p>.</span><span class=nx>Events</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>linux</span><span class=p>.</span><span class=nx>EPOLLIN</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=nb>println</span><span class=p>(</span><span class=s>&#34;runtime: netpoll: eventfd ready for&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>ev</span><span class=p>.</span><span class=nx>Events</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;runtime: netpoll: eventfd ready for something unexpected&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>continue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 调用 netpollready 唤醒等待的 goroutine</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>pd</span><span class=p>.</span><span class=nx>fdseq</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nx>tag</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nx>pd</span><span class=p>.</span><span class=nf>setEventErr</span><span class=p>(</span><span class=nx>ev</span><span class=p>.</span><span class=nx>Events</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nx>linux</span><span class=p>.</span><span class=nx>EPOLLERR</span><span class=p>,</span><span class=w> </span><span class=nx>tag</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nx>delta</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=nf>netpollready</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>toRun</span><span class=p>,</span><span class=w> </span><span class=nx>pd</span><span class=p>,</span><span class=w> </span><span class=nx>mode</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>toRun</span><span class=p>,</span><span class=w> </span><span class=nx>delta</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p><strong>4、从其他p处窃取g</strong></p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>stealWork</span><span class=p>(</span><span class=nx>now</span><span class=w> </span><span class=kt>int64</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=nx>gp</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=p>,</span><span class=w> </span><span class=nx>inheritTime</span><span class=w> </span><span class=kt>bool</span><span class=p>,</span><span class=w> </span><span class=nx>rnow</span><span class=p>,</span><span class=w> </span><span class=nx>pollUntil</span><span class=w> </span><span class=kt>int64</span><span class=p>,</span><span class=w> </span><span class=nx>newWork</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>getg</span><span class=p>().</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>const</span><span class=w> </span><span class=nx>stealTries</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>stealTries</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 通过随机数以随机起点随机步长选取目标 p 进行窃取，实现方式是stealOrder保存着p的总数count，和与count互质的数，如果 X 和 N 互质，序列 (i + X) % N 会不重复地遍历 0 到 N-1 的所有数字，实现随机性</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>for</span><span class=w> </span><span class=nx>enum</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>stealOrder</span><span class=p>.</span><span class=nf>start</span><span class=p>(</span><span class=nf>cheaprand</span><span class=p>());</span><span class=w> </span><span class=p>!</span><span class=nx>enum</span><span class=p>.</span><span class=nf>done</span><span class=p>();</span><span class=w> </span><span class=nx>enum</span><span class=p>.</span><span class=nf>next</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=c1>// 获取要窃取的p</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>p2</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>allp</span><span class=p>[</span><span class=nx>enum</span><span class=p>.</span><span class=nf>position</span><span class=p>()]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=nx>pp</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nx>p2</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>continue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=c1>// Don&#39;t bother to attempt to steal if p2 is idle.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>idlepMask</span><span class=p>.</span><span class=nf>read</span><span class=p>(</span><span class=nx>enum</span><span class=p>.</span><span class=nf>position</span><span class=p>())</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 窃取目标 p2，其中会尝试将目标 p2 lrq 中半数 g 窃取到当前 p 的 lrq 中</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>runqsteal</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span><span class=w> </span><span class=nx>p2</span><span class=p>,</span><span class=w> </span><span class=nx>stealTimersOrRunNextG</span><span class=p>);</span><span class=w> </span><span class=nx>gp</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>					</span><span class=k>return</span><span class=w> </span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=nx>now</span><span class=p>,</span><span class=w> </span><span class=nx>pollUntil</span><span class=p>,</span><span class=w> </span><span class=nx>ranTimer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 窃取失败</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>,</span><span class=w> </span><span class=nx>now</span><span class=p>,</span><span class=w> </span><span class=nx>pollUntil</span><span class=p>,</span><span class=w> </span><span class=nx>ranTimer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p><strong>5、释放p和m</strong></p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>releasep</span><span class=p>()</span><span class=w> </span><span class=o>*</span><span class=nx>p</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nf>releasepNoTrace</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>releasepNoTrace</span><span class=p>()</span><span class=w> </span><span class=o>*</span><span class=nx>p</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>getg</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;releasep: invalid arg&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>status</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>_Prunning</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nb>print</span><span class=p>(</span><span class=s>&#34;releasep: m=&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>,</span><span class=w> </span><span class=s>&#34; m-&gt;p=&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>(),</span><span class=w> </span><span class=s>&#34; p-&gt;m=&#34;</span><span class=p>,</span><span class=w> </span><span class=nf>hex</span><span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>m</span><span class=p>),</span><span class=w> </span><span class=s>&#34; p-&gt;status=&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>status</span><span class=p>,</span><span class=w> </span><span class=s>&#34;\n&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;releasep: invalid p state&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pp</span><span class=p>.</span><span class=nx>m</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pp</span><span class=p>.</span><span class=nx>status</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>_Pidle</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>pp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=cp>//go:nowritebarrierrec</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>pidleput</span><span class=p>(</span><span class=nx>pp</span><span class=w> </span><span class=o>*</span><span class=nx>p</span><span class=p>,</span><span class=w> </span><span class=nx>now</span><span class=w> </span><span class=kt>int64</span><span class=p>)</span><span class=w> </span><span class=kt>int64</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>assertLockHeld</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nf>runqempty</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;pidleput: P has non-empty run queue&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>now</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>now</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>nanotime</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>timers</span><span class=p>.</span><span class=nx>len</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>timerpMask</span><span class=p>.</span><span class=nb>clear</span><span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>id</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>idlepMask</span><span class=p>.</span><span class=nf>set</span><span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>id</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pp</span><span class=p>.</span><span class=nx>link</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>sched</span><span class=p>.</span><span class=nx>pidle</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>sched</span><span class=p>.</span><span class=nx>pidle</span><span class=p>.</span><span class=nf>set</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>sched</span><span class=p>.</span><span class=nx>npidle</span><span class=p>.</span><span class=nf>Add</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>return</span><span class=w> </span><span class=nx>now</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>stopm:</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Stops execution of the current m until new work is available.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// Returns with acquired P.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>stopm</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>getg</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>locks</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;stopm holding locks&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;stopm holding p&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>spinning</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>throw</span><span class=p>(</span><span class=s>&#34;stopm spinning&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 放入schd的全局空闲m队列</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>mput</span><span class=p>(</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 阻塞m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>mPark</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// mPark返回后意味着 m 唤醒尝试获取p</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>acquirep</span><span class=p>(</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>nextp</span><span class=p>.</span><span class=nf>ptr</span><span class=p>())</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>nextp</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><h4 id=242-execute>2.4.2 execute</h4><p>gmp调度的最后一公里，完成从调度器到用户代码的最后一跳</p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 执行给定的 g. 当前执行方还是 g0，但会通过 gogo 方法切换至 gp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>execute</span><span class=p>(</span><span class=nx>gp</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=p>,</span><span class=w> </span><span class=nx>inheritTime</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 获取m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>mp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>getg</span><span class=p>().</span><span class=nx>m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// Assign gp.m before entering _Grunning so running Gs have an M.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>mp</span><span class=p>.</span><span class=nx>curg</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>gp</span><span class=w>  </span><span class=c1>// 指定当前m运行的g</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>mp</span><span class=w>		</span><span class=c1>// g绑定的m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 切换到运行态</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>_Grunnable</span><span class=p>,</span><span class=w> </span><span class=nx>_Grunning</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>preempt</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>false</span><span class=w>	</span><span class=cp>//清除抢占标识</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>stackguard0</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>stack</span><span class=p>.</span><span class=nx>lo</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=nx>stackGuard</span><span class=w>	</span><span class=c1>// 设置栈边界</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 不是继承p的时间片时，调度次数加1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>inheritTime</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>mp</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>().</span><span class=nx>schedtick</span><span class=o>++</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// g0切换至g，运行用户g，通过汇编实现，不会返回了，goroutine 执行完毕后会调用 goexit()，在goexit会再次调用schedule()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>gogo</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>gp</span><span class=p>.</span><span class=nx>sched</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// func gogo(buf *gobuf)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// restore state from Gobuf; longjmp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>TEXT</span><span class=w> </span><span class=nx>runtime</span><span class=err>·</span><span class=nf>gogo</span><span class=p>(</span><span class=nx>SB</span><span class=p>),</span><span class=w> </span><span class=nx>NOSPLIT</span><span class=p>,</span><span class=w> </span><span class=err>$</span><span class=mi>0</span><span class=o>-</span><span class=mi>8</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>MOVQ</span><span class=w>	</span><span class=nx>buf</span><span class=o>+</span><span class=mi>0</span><span class=p>(</span><span class=nx>FP</span><span class=p>),</span><span class=w> </span><span class=nx>BX</span><span class=w>		</span><span class=c1>// BX = gobuf 地址</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>MOVQ</span><span class=w>	</span><span class=nf>gobuf_g</span><span class=p>(</span><span class=nx>BX</span><span class=p>),</span><span class=w> </span><span class=nx>DX</span><span class=w>	</span><span class=c1>// DX = gp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>MOVQ</span><span class=w>	</span><span class=mi>0</span><span class=p>(</span><span class=nx>DX</span><span class=p>),</span><span class=w> </span><span class=nx>CX</span><span class=w>		</span><span class=c1>// make sure g != nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>JMP</span><span class=w>	</span><span class=nx>gogo</span><span class=p>&lt;&gt;(</span><span class=nx>SB</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=nx>TEXT</span><span class=w> </span><span class=nx>gogo</span><span class=p>&lt;&gt;(</span><span class=nx>SB</span><span class=p>),</span><span class=w> </span><span class=nx>NOSPLIT</span><span class=p>,</span><span class=w> </span><span class=err>$</span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>get_tls</span><span class=p>(</span><span class=nx>CX</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>MOVQ</span><span class=w>	</span><span class=nx>DX</span><span class=p>,</span><span class=w> </span><span class=nf>g</span><span class=p>(</span><span class=nx>CX</span><span class=p>)</span><span class=w>	</span><span class=c1>// 设置 TLS 中的 g</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>MOVQ</span><span class=w>	</span><span class=nx>DX</span><span class=p>,</span><span class=w> </span><span class=nx>R14</span><span class=w>		</span><span class=c1>// set the g register</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>MOVQ</span><span class=w>	</span><span class=nf>gobuf_sp</span><span class=p>(</span><span class=nx>BX</span><span class=p>),</span><span class=w> </span><span class=nx>SP</span><span class=w>	</span><span class=c1>// restore SP 恢复栈指针</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>MOVQ</span><span class=w>	</span><span class=nf>gobuf_ctxt</span><span class=p>(</span><span class=nx>BX</span><span class=p>),</span><span class=w> </span><span class=nx>DX</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>MOVQ</span><span class=w>	</span><span class=nf>gobuf_bp</span><span class=p>(</span><span class=nx>BX</span><span class=p>),</span><span class=w> </span><span class=nx>BP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>MOVQ</span><span class=w>	</span><span class=err>$</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=nf>gobuf_sp</span><span class=p>(</span><span class=nx>BX</span><span class=p>)</span><span class=w>	</span><span class=c1>// clear to help garbage collector</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>MOVQ</span><span class=w>	</span><span class=err>$</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=nf>gobuf_ctxt</span><span class=p>(</span><span class=nx>BX</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>MOVQ</span><span class=w>	</span><span class=err>$</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=nf>gobuf_bp</span><span class=p>(</span><span class=nx>BX</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>MOVQ</span><span class=w>	</span><span class=nf>gobuf_pc</span><span class=p>(</span><span class=nx>BX</span><span class=p>),</span><span class=w> </span><span class=nx>BX</span><span class=w>	</span><span class=c1>// BX = 要跳转的 PC</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>JMP</span><span class=w>	</span><span class=nx>BX</span></span></span></code></pre></div></div><p>用户 g 的一个生命周期大致如下：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-bash"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>创建 -&gt; _Grunnable -&gt; execute<span class=o>()</span> -&gt; _Grunning -&gt; 用户代码执行 -&gt; goexit<span class=o>()</span> -&gt; goexit0<span class=o>()</span> -&gt; schedule<span class=o>()</span> -&gt; execute<span class=o>(</span>下一个 G<span class=o>)</span></span></span></code></pre></div></div><h2 id=3让渡设计>3、让渡设计</h2><h3 id=31-g执行完后让渡>3.1 g执行完后让渡</h3><p>g 执行完后退出</p><p>自动调用 runtime·goexit，进而 runtime·goexit1，在 runtime·goexit1 中通过 <code>mcall(goexit0) </code>切换到 g0，调用goexit0</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>TEXT</span><span class=w> </span><span class=nx>runtime</span><span class=err>·</span><span class=nf>goexit</span><span class=p>(</span><span class=nx>SB</span><span class=p>),</span><span class=nx>NOSPLIT</span><span class=p>|</span><span class=nx>TOPFRAME</span><span class=p>|</span><span class=nx>NOFRAME</span><span class=p>,</span><span class=err>$</span><span class=mi>0</span><span class=o>-</span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>BYTE</span><span class=w>	</span><span class=err>$</span><span class=mh>0x90</span><span class=w>	</span><span class=c1>// NOP</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>CALL</span><span class=w>	</span><span class=nx>runtime</span><span class=err>·</span><span class=nf>goexit1</span><span class=p>(</span><span class=nx>SB</span><span class=p>)</span><span class=w>	</span><span class=c1>// does not return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// goexit continuation on g0.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>goexit0</span><span class=p>(</span><span class=nx>gp</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>gdestroy</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>schedule</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>gdestroy</span><span class=p>(</span><span class=nx>gp</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>mp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>getg</span><span class=p>().</span><span class=nx>m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>mp</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 状态切换</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>_Grunning</span><span class=p>,</span><span class=w> </span><span class=nx>_Gdead</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 解除 M ↔ G 的关联</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>locked</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>lockedm</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>lockedm</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>mp</span><span class=p>.</span><span class=nx>lockedg</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 清理 goroutine 的各种字段</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>preemptStop</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>paniconfault</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>_defer</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=c1>// should be true already but just in case.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>_panic</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=c1>// non-nil for Goexit during panic. points at stack-allocated data.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>writebuf</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>waitreason</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>waitReasonZero</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>param</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>labels</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>timer</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>nil</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 解除当前 M 和 G 的关联，清除双向指针：M.curg 和 G.m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>dropg</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 加入到 p 的本地空闲 gFree队列，当创建新的 goroutine 时（newproc1），会先从空闲列表获取</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>gfput</span><span class=p>(</span><span class=nx>pp</span><span class=p>,</span><span class=w> </span><span class=nx>gp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><h3 id=32-g主动让渡>3.2 g主动让渡</h3><p>g主动让渡指的是由用户手动调用 runtime.Gosched 方法让出 g 所持有的执行权。在 Gosched 方法中，会通过 mcall 指令切换至 g0，并由 g0 执行 gosched_m 方法，其中包含如下步骤：</p><ul><li>将 g 由 running 改为 runnable 状态</li><li>解除 g 和 m 的关系</li><li>将 g 直接添加到全局队列 grq 中</li><li>调用 schedule 方法发起新一轮调度</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 主动让渡出执行权，此时执行方还是普通 g</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>Gosched</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 通过 mcall，将执行方转为 g0，调用 gosched_m 方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>mcall</span><span class=p>(</span><span class=nx>gosched_m</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 将 gp 切换回就绪态后添加到全局队列 grq，并发起新一轮调度</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 此时执行方为 g0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>gosched_m</span><span class=p>(</span><span class=nx>gp</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>goschedImpl</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>goschedImpl</span><span class=p>(</span><span class=nx>gp</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 将 g 状态由 running 改为 runnable 就绪态</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>_Grunning</span><span class=p>,</span><span class=w> </span><span class=nx>_Grunnable</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 解除 g 和 m 的关系</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>dropg</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 将 g 添加到全局队列 grq</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>globrunqput</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 发起新一轮调度</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>schedule</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><h3 id=33-g阻塞让渡>3.3 g阻塞让渡</h3><p>G阻塞让渡指的是 g 在执行过程中有需要等待的外部资源，需要进入阻塞等待的状态（waiting），直到条件达成后才能完成将状态重新更新为就绪态（runnable），如：Channel 操作阻塞、Select 语句阻塞、网络 I/O 等待</p><p>通过 runtime/proc.go 的 gopark 方法实现：</p><ul><li>通过 mcall 从 g 切换至 g0，并由 g0 执行 park_m 方法</li><li>g0 将 g 由 running 更新为 waiting 状态，然后发起新一轮调度</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 此时执行方为普通 g</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>gopark</span><span class=p>(</span><span class=nx>unlockf</span><span class=w> </span><span class=kd>func</span><span class=p>(</span><span class=o>*</span><span class=nx>g</span><span class=p>,</span><span class=w> </span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>)</span><span class=w> </span><span class=kt>bool</span><span class=p>,</span><span class=w> </span><span class=nx>lock</span><span class=w> </span><span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span><span class=p>,</span><span class=w> </span><span class=nx>reason</span><span class=w> </span><span class=nx>waitReason</span><span class=p>,</span><span class=w> </span><span class=nx>traceEv</span><span class=w> </span><span class=kt>byte</span><span class=p>,</span><span class=w> </span><span class=nx>traceskip</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 获取 m 正在执行的 g，也就是要阻塞让渡的 g</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nx>mp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>acquirem</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>mp</span><span class=p>.</span><span class=nx>curg</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=o>......</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 通过 mcall，将执行方由普通 g -&gt; g0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>mcall</span><span class=p>(</span><span class=nx>park_m</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 此时执行方为 g0. 入参 gp 为需要执行 park 的普通 g</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>park_m</span><span class=p>(</span><span class=nx>gp</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 获取 m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>mp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>getg</span><span class=p>().</span><span class=nx>m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 将 gp 状态由 running 变更为 waiting</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>_Grunning</span><span class=p>,</span><span class=w> </span><span class=nx>_Gwaiting</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 解绑 g 与 m 的关系</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>dropg</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// g0 发起新一轮调度流程</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>schedule</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>相反，唤醒 g 的方法是 goready 方法，通过 systemstack 压栈切换至 g0 执行 ready 方法——将目标 g 状态由 waiting 改为 runnable，然后添加到就绪队列中。</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 此时执行方为普通 g. 入参 gp 为需要唤醒的另一个普通 g</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>goready</span><span class=p>(</span><span class=nx>gp</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=p>,</span><span class=w> </span><span class=nx>traceskip</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=c1>// 调用 systemstack 后，会切换至 g0 调用传入的 ready 方法. 调用结束后则会直接切换回到当前普通 g 继续执行. </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>systemstack</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>ready</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>traceskip</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 恢复成普通 g 继续执行 ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 此时执行方为 g0. 入参 gp 为拟唤醒的普通 g</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>ready</span><span class=p>(</span><span class=nx>gp</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=p>,</span><span class=w> </span><span class=nx>traceskip</span><span class=w> </span><span class=kt>int</span><span class=p>,</span><span class=w> </span><span class=nx>next</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>mp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>acquirem</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>_Gwaiting</span><span class=p>,</span><span class=w> </span><span class=nx>_Grunnable</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>      1) 优先将目标 g 添加到当前 p 的本地队列 lrq
</span></span></span><span class=line><span class=cl><span class=cm>      2）若 lrq 满了，则将 g 追加到全局队列 grq
</span></span></span><span class=line><span class=cl><span class=cm>  */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>runqput</span><span class=p>(</span><span class=nx>mp</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>(),</span><span class=w> </span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>next</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 如果有 m 或 p 处于 idle 状态，将其唤醒</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>wakep</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><h2 id=4抢占设计>4、抢占设计</h2><p>抢占和让渡有相同之处，都表示由 g->g0 的流转过程，但区别在于，让渡是由 g 主动发起的（第一人称），而抢占则是由外力干预（sysmon thread监控线程）发起的（第三人称）。</p><p>程序启动创建 main goroutine时，在运行时的 main 函数中，会启动一个全局唯一的监控线程 sysmon thread，定时执行监控工作，包括：</p><ul><li>从网络轮询中将就绪的 g 放到运行队列</li><li>retake 抢占长时间运行的 Goroutine 和夺回阻塞的 P</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>main</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nx>mainStarted</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>if</span><span class=w> </span><span class=nx>haveSysmon</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nf>systemstack</span><span class=p>(</span><span class=kd>func</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nf>newm</span><span class=p>(</span><span class=nx>sysmon</span><span class=p>,</span><span class=w> </span><span class=kc>nil</span><span class=p>,</span><span class=w> </span><span class=o>-</span><span class=mi>1</span><span class=p>)</span><span class=w>  </span><span class=c1>// 通过newm创建新线程，执行sysmon函数，ID 为 -1，标记为系统线程</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Always runs without a P, so write barriers are not allowed.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=cp>//go:nowritebarrierrec</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>sysmon</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>sched</span><span class=p>.</span><span class=nx>nmsys</span><span class=o>++</span><span class=w> </span><span class=c1>// 增加系统 M 计数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>......</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>for</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 根据闲忙情况调整轮询间隔，在空闲情况下 10 ms 轮询一次</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>idle</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>delay</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>20</span><span class=w>  </span><span class=c1>// 开始时睡眠 20 微秒</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=nx>idle</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=mi>50</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>delay</span><span class=w> </span><span class=o>*=</span><span class=w> </span><span class=mi>2</span><span class=w>  </span><span class=c1>// 1ms 后开始加倍睡眠时间</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>delay</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=mi>10</span><span class=o>*</span><span class=mi>1000</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>delay</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>10</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=mi>1000</span><span class=w>  </span><span class=c1>// 最多睡眠 10ms</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>usleep</span><span class=p>(</span><span class=nx>delay</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 将就绪的网络 goroutine 重新放入运行队列</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// poll network if not polled for more than 10ms</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>lastpoll</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>sched</span><span class=p>.</span><span class=nx>lastpoll</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nf>netpollinited</span><span class=p>()</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>lastpoll</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>lastpoll</span><span class=o>+</span><span class=mi>10</span><span class=o>*</span><span class=mi>1000</span><span class=o>*</span><span class=mi>1000</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nx>now</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lastpoll</span><span class=p>.</span><span class=nf>CompareAndSwap</span><span class=p>(</span><span class=nx>lastpoll</span><span class=p>,</span><span class=w> </span><span class=nx>now</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>list</span><span class=p>,</span><span class=w> </span><span class=nx>delta</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>netpoll</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=c1>// non-blocking - returns list of goroutines</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>list</span><span class=p>.</span><span class=nf>empty</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=nf>incidlelocked</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=nf>injectglist</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>list</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=nf>incidlelocked</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>				</span><span class=nf>netpollAdjustWaiters</span><span class=p>(</span><span class=nx>delta</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// 抢占长时间运行的 Goroutine 和夺回阻塞的 P</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// retake P&#39;s blocked in syscalls</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// and preempt long running G&#39;s</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nf>retake</span><span class=p>(</span><span class=nx>now</span><span class=p>)</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>idle</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>	</span><span class=c1>// 有工作被抢占，重置空闲计数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=nx>idle</span><span class=o>++</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// check if we need to force a GC</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>if</span><span class=w> </span><span class=nx>t</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=p>(</span><span class=nx>gcTrigger</span><span class=p>{</span><span class=nx>kind</span><span class=p>:</span><span class=w> </span><span class=nx>gcTriggerTime</span><span class=p>,</span><span class=w> </span><span class=nx>now</span><span class=p>:</span><span class=w> </span><span class=nx>now</span><span class=p>});</span><span class=w> </span><span class=nx>t</span><span class=p>.</span><span class=nf>test</span><span class=p>()</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>forcegc</span><span class=p>.</span><span class=nx>idle</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>			</span><span class=o>...</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>sysmonlock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>下面主要关注 retake：</p><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>retake</span><span class=p>(</span><span class=nx>now</span><span class=w> </span><span class=kt>int64</span><span class=p>)</span><span class=w> </span><span class=kt>uint32</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>n</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w> </span><span class=nx>i</span><span class=w> </span><span class=p>&lt;</span><span class=w> </span><span class=nb>len</span><span class=p>(</span><span class=nx>allp</span><span class=p>);</span><span class=w> </span><span class=nx>i</span><span class=o>++</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>pp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>allp</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>pd</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=o>&amp;</span><span class=nx>pp</span><span class=p>.</span><span class=nx>sysmontick</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>s</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>status</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 情况 1: P 正在运行或在系统调用中</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>s</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nx>_Prunning</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nx>s</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nx>_Psyscall</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>t</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>int64</span><span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>schedtick</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=nb>int64</span><span class=p>(</span><span class=nx>pd</span><span class=p>.</span><span class=nx>schedtick</span><span class=p>)</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>t</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// schedtick 变化了，说明有新的 G 在运行</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nx>pd</span><span class=p>.</span><span class=nx>schedtick</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nb>uint32</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nx>pd</span><span class=p>.</span><span class=nx>schedwhen</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>now</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=nx>pd</span><span class=p>.</span><span class=nx>schedwhen</span><span class=o>+</span><span class=nx>forcePreemptNS</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=nx>now</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// 同一个 G 运行超过 10ms，抢占它</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nf>preemptone</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nx>sysretake</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 情况 2: P 在系统调用中</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nx>s</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nx>_Psyscall</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>t</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>int64</span><span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>syscalltick</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>sysretake</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nb>int64</span><span class=p>(</span><span class=nx>pd</span><span class=p>.</span><span class=nx>syscalltick</span><span class=p>)</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>t</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nx>pd</span><span class=p>.</span><span class=nx>syscalltick</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nb>uint32</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nx>pd</span><span class=p>.</span><span class=nx>syscallwhen</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>now</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>continue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 系统调用超过 20us，且有其他工作要做</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=nf>runqempty</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>sched</span><span class=p>.</span><span class=nx>nmspinning</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span><span class=o>+</span><span class=nx>sched</span><span class=p>.</span><span class=nx>npidle</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>pd</span><span class=p>.</span><span class=nx>syscallwhen</span><span class=o>+</span><span class=mi>10</span><span class=o>*</span><span class=mi>1000</span><span class=o>*</span><span class=mi>1000</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=nx>now</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>continue</span><span class=w>  </span><span class=c1>// P 的队列为空，不夺回</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// 夺回 P</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>Cas</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pp</span><span class=p>.</span><span class=nx>status</span><span class=p>,</span><span class=w> </span><span class=nx>s</span><span class=p>,</span><span class=w> </span><span class=nx>_Pidle</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nx>n</span><span class=o>++</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nx>pp</span><span class=p>.</span><span class=nx>syscalltick</span><span class=o>++</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=nf>handoffp</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span><span class=w>  </span><span class=c1>// 将 P 交给其他 M</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nb>uint32</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>两种抢占场景：
场景 A：抢占长时间运行的 Goroutine</p><p>场景 B：夺回阻塞在系统调用中的 P</p><h3 id=41-超时抢占>4.1 超时抢占</h3><p>时间阈值：10 毫秒（forcePreemptNS = 10 * 1000 * 1000）
触发条件：同一个 G（或通过 runnext 共享时间片的 G 序列）运行超过 10ms
抢占方式：</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>preemptone</span><span class=p>(</span><span class=nx>pp</span><span class=w> </span><span class=o>*</span><span class=nx>p</span><span class=p>)</span><span class=w> </span><span class=kt>bool</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  	</span><span class=nx>mp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  	</span><span class=c1>// 获取 p 上正在执行的 g（抢占目标）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>mp</span><span class=p>.</span><span class=nx>curg</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>gp</span><span class=p>.</span><span class=nx>preempt</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>gp</span><span class=p>.</span><span class=nx>stackguard0</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>stackPreempt</span><span class=w>  </span><span class=c1>// 设置栈边界为stackPreempt，当g执行时触发栈检查。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 异步抢占（发送信号）会对目标 g 所在的 m 发送抢占信号 sigPreempt，通过改写 g 程序计数器（pc，program counter）的方式将 g 逼停</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>preemptMSupported</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>debug</span><span class=p>.</span><span class=nx>asyncpreemptoff</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>pp</span><span class=p>.</span><span class=nx>preempt</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nf>preemptM</span><span class=p>(</span><span class=nx>mp</span><span class=p>)</span><span class=w>  </span><span class=c1>// 发送 SIGURG 信号</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=kc>true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// 发送抢占信号</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>preemptM</span><span class=p>(</span><span class=nx>mp</span><span class=w> </span><span class=o>*</span><span class=nx>m</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>......</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>mp</span><span class=p>.</span><span class=nx>signalPending</span><span class=p>.</span><span class=nf>CompareAndSwap</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span><span class=w> </span><span class=mi>1</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>signalM</span><span class=p>(</span><span class=nx>mp</span><span class=p>,</span><span class=w> </span><span class=nx>sigPreempt</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>signalM</span><span class=p>(</span><span class=nx>mp</span><span class=w> </span><span class=o>*</span><span class=nx>m</span><span class=p>,</span><span class=w> </span><span class=nx>sig</span><span class=w> </span><span class=kt>int</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>pthread_kill</span><span class=p>(</span><span class=nf>pthread</span><span class=p>(</span><span class=nx>mp</span><span class=p>.</span><span class=nx>procid</span><span class=p>),</span><span class=w> </span><span class=nb>uint32</span><span class=p>(</span><span class=nx>sig</span><span class=p>))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><h3 id=42-系统调用抢占>4.2 系统调用抢占</h3><p>在发起系统调用时，会执行位于 runtime/proc.go 的 reentersyscall 方法，此方法核心步骤包括：</p><ul><li>将 g 和 p 的状态更新为 syscall</li><li>解除 p 和 m 的绑定</li><li>将 p 设置为 m.oldp，保留 p 与 m 之间的弱联系（使得 m syscall 结束后，还有一次尝试复用 p 的机会）</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>reentersyscall</span><span class=p>(</span><span class=nx>pc</span><span class=p>,</span><span class=w> </span><span class=nx>sp</span><span class=w> </span><span class=kt>uintptr</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 获取 g</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>getg</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 保存寄存器信息</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>save</span><span class=p>(</span><span class=nx>pc</span><span class=p>,</span><span class=w> </span><span class=nx>sp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 将 g 状态更新为 syscall</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>casgstatus</span><span class=p>(</span><span class=nx>_g_</span><span class=p>,</span><span class=w> </span><span class=nx>_Grunning</span><span class=p>,</span><span class=w> </span><span class=nx>_Gsyscall</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 解除 p 与 m 绑定关系</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>pp</span><span class=p>.</span><span class=nx>m</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 将 p 设置为 m 的 oldp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>oldp</span><span class=p>.</span><span class=nf>set</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>p</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 将 p 状态更新为 syscall</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>atomic</span><span class=p>.</span><span class=nf>Store</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pp</span><span class=p>.</span><span class=nx>status</span><span class=p>,</span><span class=w> </span><span class=nx>_Psyscall</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>当系统系统调用完成时，会执行位于 runtime/proc.go 的 exitsyscall 方法（此时执行方还是 m 上的 g），包含如下步骤：</p><ul><li>检查 syscall 期间，p 是否未和其他 m 结合，如果是的话，直接复用 p，继续执行 g</li><li>通过 mcall 操作切换至 g0 执行 exitsyscall0 方法，尝试为当前 m 结合一个新的 p，如果结合成功，则继续执行 g，否则将 g 添加到 grq 后暂停 m</li></ul><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>exitsyscall</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 获取 g</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>gp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>getg</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 如果 oldp 没有和其他 m 结合，则直接复用 oldp</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>oldp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nx>_g_</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>oldp</span><span class=p>.</span><span class=nf>ptr</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nx>_g_</span><span class=p>.</span><span class=nx>m</span><span class=p>.</span><span class=nx>oldp</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nf>exitsyscallfast</span><span class=p>(</span><span class=nx>oldp</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 将 g 状态由 syscall 更新回 running</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>casgstatus</span><span class=p>(</span><span class=nx>_g_</span><span class=p>,</span><span class=w> </span><span class=nx>_Gsyscall</span><span class=p>,</span><span class=w> </span><span class=nx>_Grunning</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	 </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 切换至 g0 调用 exitsyscall0 方法</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>mcall</span><span class=p>(</span><span class=nx>exitsyscall0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><div class="code-block code-line-numbers" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 此时执行方为 m 下的 g0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>exitsyscall0</span><span class=p>(</span><span class=nx>gp</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 将 g 的状态修改为 runnable 就绪态</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>casgstatus</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=nx>_Gsyscall</span><span class=p>,</span><span class=w> </span><span class=nx>_Grunnable</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=c1>// 解除 g 和 m 的绑定关系</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>dropg</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>lock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 尝试寻找一个空闲的 p 与当前 m 结合</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>var</span><span class=w> </span><span class=nx>pp</span><span class=w> </span><span class=o>*</span><span class=nx>p</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nf>schedEnabled</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nx>pp</span><span class=p>,</span><span class=w> </span><span class=nx>_</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nf>pidleget</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=kd>var</span><span class=w> </span><span class=nx>locked</span><span class=w> </span><span class=kt>bool</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 如果与 p 结合失败，则将 g 添加到全局队列中</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>pp</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>globrunqput</span><span class=p>(</span><span class=nx>gp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>sched</span><span class=p>.</span><span class=nx>lock</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 如果与 p 结合成功，则继续调度 g </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=nx>pp</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=kc>nil</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>acquirep</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>execute</span><span class=p>(</span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>)</span><span class=w> </span><span class=c1>// Never returns.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 与 p 结合失败的话，需要将当前 m 添加到 schedt 的 midle 队列并停止 m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>stopm</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=c1>// 如果 m 被重新启用，则发起新一轮调度</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>schedule</span><span class=p>()</span><span class=w> </span><span class=c1>// Never returns.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>回到 sysmon thread 中的 retake 方法，此处会遍历每个 p，并针对正在发起系统调用的 p 执行如下检查逻辑：</p><ul><li>检查 p 的 lrq 中是否存在等待执行的 g</li><li>检查 p 的 syscall 时长是否 >= 10ms</li></ul><p>处理方式：
将 P 的状态改为 _Pidle
调用 handoffp(pp) 将 P 交给其他 M 使用
原来的 M 从系统调用返回后会寻找新的 P</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>retake</span><span class=p>(</span><span class=nx>now</span><span class=w> </span><span class=kt>int64</span><span class=p>)</span><span class=w> </span><span class=kt>uint32</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 情况 2: P 在系统调用中</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=k>if</span><span class=w> </span><span class=nx>s</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nx>_Psyscall</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nx>t</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>int64</span><span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>syscalltick</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>sysretake</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nb>int64</span><span class=p>(</span><span class=nx>pd</span><span class=p>.</span><span class=nx>syscalltick</span><span class=p>)</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>t</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nx>pd</span><span class=p>.</span><span class=nx>syscalltick</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nb>uint32</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nx>pd</span><span class=p>.</span><span class=nx>syscallwhen</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>now</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=k>continue</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=c1>// 系统调用超过 20us，且有其他工作要做</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>if</span><span class=w> </span><span class=nf>runqempty</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>sched</span><span class=p>.</span><span class=nx>nmspinning</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span><span class=o>+</span><span class=nx>sched</span><span class=p>.</span><span class=nx>npidle</span><span class=p>.</span><span class=nf>Load</span><span class=p>()</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=mi>0</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>pd</span><span class=p>.</span><span class=nx>syscallwhen</span><span class=o>+</span><span class=mi>10</span><span class=o>*</span><span class=mi>1000</span><span class=o>*</span><span class=mi>1000</span><span class=w> </span><span class=p>&gt;</span><span class=w> </span><span class=nx>now</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=k>continue</span><span class=w>  </span><span class=c1>// P 的队列为空，不夺回</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=c1>// 夺回 P</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>if</span><span class=w> </span><span class=nx>atomic</span><span class=p>.</span><span class=nf>Cas</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>pp</span><span class=p>.</span><span class=nx>status</span><span class=p>,</span><span class=w> </span><span class=nx>s</span><span class=p>,</span><span class=w> </span><span class=nx>_Pidle</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nx>n</span><span class=o>++</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nx>pp</span><span class=p>.</span><span class=nx>syscalltick</span><span class=o>++</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nf>handoffp</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span><span class=w>  </span><span class=c1>// 将 P 交给其他 M</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>handoffp</span><span class=p>(</span><span class=nx>_p_</span><span class=w> </span><span class=o>*</span><span class=nx>p</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// 如果 p lrq 中还有 g 或者全局队列 grq 中还有 g，则立即分配一个新 m 与该 p 结合</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nf>runqempty</span><span class=p>(</span><span class=nx>_p_</span><span class=p>)</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nx>sched</span><span class=p>.</span><span class=nx>runqsize</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// 分配一个 m 与 p 结合</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=nf>startm</span><span class=p>(</span><span class=nx>_p_</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>return</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// 若系统空闲没有 g 需要调度，则将 p 添加到 schedt 中的空闲 p 队列 pidle 中</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=nf>pidleput</span><span class=p>(</span><span class=nx>_p_</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><h2 id=其他>其他</h2><h3 id=1-补充>1 补充</h3><h4 id=11-g-栈空间分布>1.1 g 栈空间分布：</h4><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/goroutine%e6%a0%88%e5%88%86%e5%b8%83.png data-srcset="../images/goroutine%e6%a0%88%e5%88%86%e5%b8%83.png, ../images/goroutine%e6%a0%88%e5%88%86%e5%b8%83.png 1.5x, ../images/goroutine%e6%a0%88%e5%88%86%e5%b8%83.png 2x" data-sizes=auto alt=../images/goroutine栈分布.png title=sched_pidle></p><p>栈大小计算：
<code>stack.hi - stack.lo = 2048 字节</code> (初始栈大小，即 stackMin)</p><p>如果 <code>SP &lt; stackguard0</code>:
触发栈增长（调用 runtime.morestack）
分配更大的栈
复制旧栈内容到新栈
继续执行</p><p>除了栈溢出检测，stackguard0 还用于实现抢占。</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>gp</span><span class=p>.</span><span class=nx>stackguard0</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>stackPreempt</span><span class=w>  </span><span class=c1>// 0xfffffade（一个很大的值）</span></span></span></code></pre></div></div><p>下次函数调用时：
<code>SP (正常值) &lt; stackPreempt (超大值)</code> → 触发 morestack
morestack 检测到 <code>stackguard0 == stackPreempt</code>
执行抢占逻辑而非栈增长</p><h4 id=12-goroutine-状态转换>1.2 goroutine 状态转换</h4><p><img class=lazyload src=/svg/loading.min.svg data-src=../images/goroutine%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2%e5%9b%be.png data-srcset="../images/goroutine%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2%e5%9b%be.png, ../images/goroutine%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2%e5%9b%be.png 1.5x, ../images/goroutine%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2%e5%9b%be.png 2x" data-sizes=auto alt=../images/goroutine状态转换图.png title=goroutine状态转换图></p><h4 id=13-抢占禁用p的next槽位>1.3 抢占禁用p的next槽位</h4><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Goroutine A</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>for</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>ch</span><span class=w> </span><span class=o>&lt;-</span><span class=w> </span><span class=mi>1</span><span class=w>  </span><span class=c1>// 发送后立即阻塞，没有函数调用</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=c1>// Goroutine B  </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=k>for</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>&lt;-</span><span class=nx>ch</span><span class=w>     </span><span class=c1>// 接收后立即阻塞，没有函数调用</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>上述例子中会出现 A B 互相唤醒，互相执行，继承 p 的时间片一直执行下去，导致 p 上的其他 g 处于饥饿状态，时间片一直会被刷新，是因为从 runqget 中获取 g 时，如果 next 有值，则优先返回，并且 <code>inheritTime = true</code>,标志继承时间片。</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>runqget</span><span class=p>(</span><span class=nx>pp</span><span class=w> </span><span class=o>*</span><span class=nx>p</span><span class=p>)</span><span class=w> </span><span class=p>(</span><span class=nx>gp</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=p>,</span><span class=w> </span><span class=nx>inheritTime</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 如果 runnext 有值，优先返回它</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>next</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=nx>pp</span><span class=p>.</span><span class=nx>runnext</span><span class=p>.</span><span class=nf>cas</span><span class=p>(</span><span class=nx>next</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>return</span><span class=w> </span><span class=nx>next</span><span class=p>.</span><span class=nf>ptr</span><span class=p>(),</span><span class=w> </span><span class=kc>true</span><span class=w>  </span><span class=c1>// ← inheritTime = true</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// 否则从普通队列取</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=nx>gp</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=w>  </span><span class=c1>// ← inheritTime = false</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>在调度器执行时，会判断 <code>inheritTime</code> 标识是否为 true，为 true 则调度器计数器不增加。</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-GO"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-GO data-lang=GO><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>execute</span><span class=p>(</span><span class=nx>gp</span><span class=w> </span><span class=o>*</span><span class=nx>g</span><span class=p>,</span><span class=w> </span><span class=nx>inheritTime</span><span class=w> </span><span class=kt>bool</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nx>mp</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nf>getg</span><span class=p>().</span><span class=nx>m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ... 省略其他代码 ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>!</span><span class=nx>inheritTime</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>mp</span><span class=p>.</span><span class=nx>p</span><span class=p>.</span><span class=nf>ptr</span><span class=p>().</span><span class=nx>schedtick</span><span class=o>++</span><span class=w>  </span><span class=c1>// ← 只有 inheritTime=false 时才增加 schedtick</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ... 省略其他代码 ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nf>gogo</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>gp</span><span class=p>.</span><span class=nx>sched</span><span class=p>)</span><span class=w>  </span><span class=c1>// 开始执行 goroutine</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><p>因此，在 runqput 中如果没有系统监控主动抢占时，需要禁止 next。</p><p>系统监控抢占是通过 sysmon 检查 pp.schedtick 是否变化来判断，如果 schedtick 长时间不变，说明时间片用完，触发抢占。</p><div class="code-block code-line-numbers open" style="counter-reset:code-block 0"><div class="code-header language-go"><span class=code-title><i class="arrow fas fa-angle-right fa-fw" aria-hidden=true></i></span>
<span class=ellipses><i class="fas fa-ellipsis-h fa-fw" aria-hidden=true></i></span>
<span class=copy title=复制到剪贴板><i class="far fa-copy fa-fw" aria-hidden=true></i></span></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// sysmon 每 10ms 检查一次</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=kd>func</span><span class=w> </span><span class=nf>retake</span><span class=p>(</span><span class=nx>now</span><span class=w> </span><span class=kt>int64</span><span class=p>)</span><span class=w> </span><span class=kt>uint32</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=nx>s</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nx>_Prunning</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=nx>s</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=nx>_Psyscall</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Preempt G if it&#39;s running on the same schedtick for</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// too long. This could be from a single long-running</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// goroutine or a sequence of goroutines run via</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// runnext, which share a single schedtick time slice.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nx>t</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=nb>int64</span><span class=p>(</span><span class=nx>pp</span><span class=p>.</span><span class=nx>schedtick</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=nb>int64</span><span class=p>(</span><span class=nx>pd</span><span class=p>.</span><span class=nx>schedtick</span><span class=p>)</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=nx>t</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>pd</span><span class=p>.</span><span class=nx>schedtick</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nb>uint32</span><span class=p>(</span><span class=nx>t</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nx>pd</span><span class=p>.</span><span class=nx>schedwhen</span><span class=w> </span><span class=p>=</span><span class=w> </span><span class=nx>now</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=nx>pd</span><span class=p>.</span><span class=nx>schedwhen</span><span class=o>+</span><span class=nx>forcePreemptNS</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=nx>now</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nf>preemptone</span><span class=p>(</span><span class=nx>pp</span><span class=p>)</span><span class=w>  </span><span class=c1>// ← 抢占</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// ...</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></div></div><h4 id=14-完整启动流程>1.4 完整启动流程</h4><p>时间线：
T0: 程序启动
↓
T1: 汇编入口（asm_amd64.s）
├─ mainStarted = false（默认值）
├─ newproc(runtime.main) &lt;-创建 main goroutine
│ ├─ runqput(P0, main_g, true) &lt;-放入 runnext
│ └─ if mainStarted { wakep() } &lt;-不执行！
└─ mstart() &lt;-启动 M0</p><p>T2: M0 进入调度循环
├─ mstart0()
├─ mstart1()
└─ schedule() &lt;-永不返回</p><p>T3: schedule() 查找 goroutine
├─ findRunnable()
├─ runqget(P0) &lt;-从 runnext 取出 main goroutine
└─ execute(main_g, inheritTime=true) &lt;-继承时间片</p><p>T4: 执行 runtime.main
├─ mainStarted = true
├─ 启动 sysmon
├─ 执行 init 函数
└─ 执行 main.main() ← 执行用户代码</p><p>T5: 用户代码中创建 goroutine
├─ go func() { &mldr; }
├─ newproc(fn)
├─ runqput(P0, new_g, true)
└─ if mainStarted { wakep() } &lt;-唤醒 m 执行 g</p><h4 id=15-一个阻塞-channel-的生命周期>1.5 一个阻塞 channel 的生命周期</h4><ol><li>Goroutine 尝试从空 channel 接收</li><li>发现没有数据，需要阻塞</li><li>调用 gopark() → mcall(park_m)</li><li>park_m():<ul><li>casgstatus(gp, _Grunning, _Gwaiting) // 状态转换</li><li>dropg() // 解除 M ↔ G 关联</li><li>schedule() // 调度下一个 goroutine</li></ul></li><li>M 继续执行其他 goroutine</li><li>另一个 goroutine 向 channel 发送数据</li><li>调用 goready(gp) 唤醒阻塞的 goroutine</li><li>gp 被放入运行队列</li><li>某个 M 通过 schedule() → findrunnable() 获取 gp</li><li>execute(gp):<ul><li>mp.curg = gp // 重新建立 M → G 关联</li><li>gp.m = mp // 重新建立 G → M 关联</li><li>gogo(&amp;gp.sched) // 恢复执行</li></ul></li></ol><h3 id=2-gmp-模型的进化思想>2 GMP 模型的进化思想</h3><p>在高并发场景下，大量的线程创建、使用、切换、销毁会占用大量的内存，并浪费 CPU 时间工作在非工作任务的上，导致程序并发处理请求的能力降低。</p><h3 id=3-gmp-生态>3 GMP 生态</h3><p>go 语言中的并发工具都是以 G 为并发粒度打造的，围绕GMP构造的并发世界</p><ul><li><p>锁 mutex、通道 channel 等都是基于 GMP 适配，在执行阻塞操作时，是阻塞在 g 的粒度，而非 m 粒度，因此这里的唤醒与阻塞都在用户态完成，无需内核介入，同时阻塞一个 g 也不会影响 m 下其他 g 的运行。</p></li><li><p>在网络 io 模型方面，采用 epoll 多路复用技术，epoll_wait 阻塞在 m（thread）粒度，golang 专门设计一套 netpoll 机制，使用用户态的 gopark 指令实现阻塞操作，使用非阻塞 epoll_wait 结合用户态的 goready 指令实现唤醒操作，从而将 io 行为也控制在 g 粒度。</p></li><li><p>内存管理，继承 TCMalloc（Thread-Caching-Malloc）思路，为每一个 p 都准备了一份私有的高速缓冲 mcahe，这部分内存分配可以使得 p 无锁化。</p></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2026-02-04</span></div><div id=page-views class=post-info-mod></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/gmp/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/go/>Go</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/go_sql_drive_mysql/ class=prev rel=prev title=mysql驱动><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>mysql驱动</a>
<a href=/func/ class=next rel=next title=Func函数底层实现>Func函数底层实现<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2019 - 2026</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>zg</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i></a></div><div id=fixed-buttons-hidden><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=/lib/katex/katex.min.css><link rel=stylesheet href=/lib/cookieconsent/cookieconsent.min.css><script src=/lib/autocomplete/autocomplete.min.js></script><script src=/lib/lunr/lunr.min.js></script><script src=/lib/lunr/lunr.stemmer.support.min.js></script><script src=/lib/lunr/lunr.zh.min.js></script><script src=/lib/lazysizes/lazysizes.min.js></script><script src=/lib/clipboard/clipboard.min.js></script><script src=/lib/typeit/index.umd.js></script><script src=/lib/katex/katex.min.js></script><script src=/lib/katex/contrib/auto-render.min.js></script><script src=/lib/katex/contrib/copy-tex.min.js></script><script src=/lib/katex/contrib/mhchem.min.js></script><script src=/lib/cookieconsent/cookieconsent.min.js></script><script>window.config={comment:{},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验."},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},data:{"id-1":"zg's blog","id-2":"zg's blog"},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:30,type:"lunr"},typeit:{cursorChar:"|",cursorSpeed:1e3,data:{"id-1":["id-1"],"id-2":["id-2"]},duration:-1,speed:100}}</script><script src=/js/theme.min.js></script></body></html>